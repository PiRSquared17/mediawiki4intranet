# HG changeset patch
# User Vitaliy Filippov <vitali@st-filippov.office.custis.ru>
# Date 1266240011 -10800
Wikilog extension debug:
Bug 58154 - fix caching error
Bug 56056 - do not handle post subarticles as posts themselves

diff -r ecc1d86fc6cf -r 99d8124c86d9 extensions/Wikilog/Wikilog.php
--- extensions/Wikilog/Wikilog.php
+++ extensions/Wikilog/Wikilog.php
@@ -409,16 +409,12 @@
 		$ns = MWNamespace::getSubject( $origns );
 		$tns = MWNamespace::getTalk( $origns );
 
-		if ( strpos( $title->getText(), '/' ) !== false ) {
-			# If title contains a '/', treat as a wikilog article title.
-			list( $this->mWikilogName, $this->mItemName ) =
-				explode( '/', $title->getText(), 2 );
-
-			if ( strpos( $this->mItemName, '/' ) !== false ) {
-				list( $this->mItemName, $this->mTrailing ) =
-					explode( '/', $this->mItemName, 2 );
-			}
-
+		# If title contains a '/', treat as a wikilog article title.
+		$parts = explode('/', $title->getText());
+		if (count($parts) > 1 && ($this->mIsTalk || count($parts) == 2))
+		{
+			$this->mWikilogName = $parts[0];
+			$this->mItemName = $parts[1];
 			$rawtitle = "{$this->mWikilogName}/{$this->mItemName}";
 			$this->mWikilogTitle = Title::makeTitle( $ns, $this->mWikilogName );
 			$this->mItemTitle = Title::makeTitle( $ns, $rawtitle );
diff -r ecc1d86fc6cf -r 99d8124c86d9 extensions/Wikilog/WikilogFeed.php
--- extensions/Wikilog/WikilogFeed.php
+++ extensions/Wikilog/WikilogFeed.php
@@ -28,12 +28,14 @@
 if ( !defined( 'MEDIAWIKI' ) )
 	die();
 
+
 /**
  * Syndication feed driver. Creates feeds from a list of wikilog articles,
  * given a format and a query object.
  */
 class WikilogFeed
 {
+
 	/**
 	 * Feed title (i.e., not Wikilog title). For Special:Wikilog,
 	 * 'wikilog-specialwikilog-title' system message should be used.
@@ -131,17 +133,26 @@
 		FeedUtils::checkPurge( $timekey, $feedkey );
 
 		if ( $feed->isCacheable() ) {
+
+			# IMPORTANT
+			# When you output cached feed, you MUST NOT output the
+			# Last-Modified header value of which is greater than cache time!
+			# It is set by OutputPage::checkLastModified(), so we need to pass
+			# the "effective" timestamp instead of real feed update timestamp.
+			# See error case in getEffectiveCacheTimestamp() description.
+			$tsEffective = $this->getEffectiveCacheTimestamp($feed->getUpdated(), $timekey);
+
 			# Check if client cache is ok.
-			if ( $wgOut->checkLastModified( $feed->getUpdated() ) ) {
+			if ( $wgOut->checkLastModified( $tsEffective ) ) {
 				# Client cache is fresh. OutputPage takes care of sending
 				# the appropriate headers, nothing else to do.
 				return;
 			}
 
 			# Try to load the feed from our cache.
-			$cached = $this->loadFromCache( $feed->getUpdated(), $timekey, $feedkey );
+			$cached = $this->loadFromCache( $tsEffective, $timekey, $feedkey );
 
-			if ( is_string( $cached ) ) {
+			if( is_string( $cached ) ) {
 				wfDebug( "Wikilog: Outputting cached feed\n" );
 				$feed->httpHeaders();
 				echo $cached;
@@ -315,7 +326,7 @@
 	 */
 	public function getSiteFeedObject() {
 		global $wgContLanguageCode, $wgWikilogFeedClasses, $wgFavicon, $wgLogo;
-		$title = wfMsgForContent( 'wikilog-specialwikilog-title' );
+		$title = wfMsgForContent( 'wikilog' );
 		$subtitle = wfMsgExt( 'wikilog-feed-description', array( 'parse', 'content' ) );
 
 		$updated = $this->mDb->selectField( 'wikilog_wikilogs',
@@ -392,7 +403,7 @@
 				}
 				if ( $row->wlw_authors ) {
 					$authors = unserialize( $row->wlw_authors );
-					foreach ( $authors as $user => $userid ) {
+					foreach( $authors as $user => $userid ) {
 						$usertitle = Title::makeTitle( NS_USER, $user );
 						$feed->addAuthor( $user, $usertitle->getFullUrl() );
 					}
@@ -422,6 +433,34 @@
 	}
 
 	/**
+	 * Returns effective timestamp for cached OR uncached data.
+	 * This is needed due to $wgFeedCacheTimeout.
+	 * Suppose the following situation:
+	 * 1. Wiki caches OLD version of feed with OLD timestamp
+	 * 2. So client caches OLD version of feed with OLD timestamp
+	 * 3. User updates the wikilog - now it has NEW update timestamp
+	 * 4. It happens that client updates feed BEFORE $wgFeedCacheTimeout seconds passed after the first update
+	 * 5. So Wiki outputs OLD version of feed with NEW (!!!) timestamp (see execute())
+	 * 6. Client caches OLD version of feed with NEW (!!!) timestamp
+	 * 7. In the future, client sends requests with If-Modified-Since = NEW timestamp
+	 * 8. So Wiki outputs 304 Not Modified
+	 * 9. So client does not get the new data
+	 */
+	public function getEffectiveCacheTimestamp($tsData, $timekey)
+	{
+		global $messageMemc, $wgFeedCacheTimeout;
+		if (($wgFeedCacheTimeout > 0) &&
+		    ($tsCache = $messageMemc->get($timekey)) &&
+		    ($age = time() - wfTimestamp(TS_UNIX, $tsCache)) < $wgFeedCacheTimeout)
+		{
+			wfDebug("Wikilog: too little time passed after last feed cache time, ".
+				"using old version -- age ($age) < timeout ($wgFeedCacheTimeout)\n");
+			return $tsCache;
+		}
+		return $tsData;
+	}
+
+	/**
 	 * Load feed output from cache.
 	 *
 	 * @param $tsData Timestamp of the last change of the local data.
@@ -434,26 +473,13 @@
 		$tsCache = $messageMemc->get( $timekey );
 
 		if ( ( $wgFeedCacheTimeout > 0 ) && $tsCache ) {
-			$age = time() - wfTimestamp( TS_UNIX, $tsCache );
-
-			# XXX: Minimum feed cache age check disabled. This code is
-			# shadowed from ChangesFeed::loadFromCache(), but Vitaliy Filippov
-			# noticed that this causes the old cached feed to output with the
-			# updated last-modified timestamp, breaking cache behavior.
-			# For now, it is disabled, since this is just a performance
-			# optimization.
-			/* if ( $age < $wgFeedCacheTimeout ) {
-				wfDebug( "Wikilog: loading feed from cache -- " .
-					"too young: age ($age) < timeout ($wgFeedCacheTimeout) " .
-					"($feedkey; $tsCache; $tsData)\n" );
-				return $messageMemc->get( $feedkey );
-			} else */ if ( $tsCache >= $tsData ) {
-				wfDebug( "Wikilog: loading feed from cache -- " .
-					"not modified: cache ($tsCache) >= data ($tsData)" .
+			if ( $tsCache >= $tsData ) {
+				wfDebug( "Wikilog: loading feed from cache -- ".
+					"not modified: cache ($tsCache) >= data ($tsData)".
 					"($feedkey)\n" );
 				return $messageMemc->get( $feedkey );
 			} else {
-				wfDebug( "Wikilog: cached feed timestamp check failed -- " .
+				wfDebug( "Wikilog: cache must be invalidated -- ".
 					"cache ($tsCache) < data ($tsData)\n" );
 			}
 		}
@@ -485,7 +511,7 @@
 			$wgOut->addWikiMsg( 'feed-unavailable' );
 			return false;
 		}
-		if ( !isset( $wgWikilogFeedClasses[$this->mFormat] ) ) {
+		if( !isset( $wgWikilogFeedClasses[$this->mFormat] ) ) {
 			wfHttpError( 500, "Internal Server Error", "Unsupported feed type." );
 			return false;
 		}
@@ -539,4 +565,5 @@
 			return $title->getFullUrl();
 		}
 	}
+
 }
