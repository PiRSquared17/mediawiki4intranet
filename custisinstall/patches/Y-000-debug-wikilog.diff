# HG changeset patch
# User Vitaliy Filippov <vitali@st-filippov.office.custis.ru>
# Date 1269270633 -10800
Wikilog extension debug:
Bug 58154 - fix caching error
Bug 56056 - do not handle post subarticles as posts themselves
Bug 61175 - Default sort direction
Bug 61149 - Show wikilog name in site feed
Bug 51595 - Use DOM to extract summary from article content
Bug 61632 - Make comment author signatures using generic mechanism
Bug 61174 - Preview does not get parsed

diff -r 2f012c39365a -r 7c07352c6224 extensions/Wikilog/Wikilog.php
--- extensions/Wikilog/Wikilog.php
+++ extensions/Wikilog/Wikilog.php
@@ -423,16 +423,13 @@
 		$ns = MWNamespace::getSubject( $origns );
 		$tns = MWNamespace::getTalk( $origns );
 
-		if ( strpos( $title->getText(), '/' ) !== false ) {
-			# If title contains a '/', treat as a wikilog article title.
-			list( $this->mWikilogName, $this->mItemName ) =
-				explode( '/', $title->getText(), 2 );
-
-			if ( strpos( $this->mItemName, '/' ) !== false ) {
-				list( $this->mItemName, $this->mTrailing ) =
-					explode( '/', $this->mItemName, 2 );
-			}
-
+		# If title contains a '/', treat as a wikilog article title.
+		$parts = explode('/', $title->getText());
+		if (count($parts) > 1 && ($this->mIsTalk || count($parts) == 2))
+		{
+			$this->mWikilogName = array_shift($parts);
+			$this->mItemName = array_shift($parts);
+			$this->mTrailing = implode('/', $parts);
 			$rawtitle = "{$this->mWikilogName}/{$this->mItemName}";
 			$this->mWikilogTitle = Title::makeTitle( $ns, $this->mWikilogName );
 			$this->mItemTitle = Title::makeTitle( $ns, $rawtitle );
diff -r 2f012c39365a -r 7c07352c6224 extensions/Wikilog/WikilogComment.php
--- extensions/Wikilog/WikilogComment.php
+++ extensions/Wikilog/WikilogComment.php
@@ -612,7 +612,10 @@
 				list( $article, $parserOutput ) = WikilogUtils::parsedArticle( $comment->mCommentTitle );
 				$text = $parserOutput->getText();
 			} else {
+				global $wgParser, $wgUser, $wgTitle;
 				$text = $comment->getText();
+				$text = $wgParser->parse($text, $wgTitle, ParserOptions::newFromUser( $wgUser ));
+				$text = $text->getText();
 			}
 
 			if ( $text ) {
@@ -698,12 +701,7 @@
 
 		if ( $comment->mUserID ) {
 			$authorPlain = htmlspecialchars( $comment->mUserText );
-			$authorFmt = wfMsgExt( 'wikilog-simple-signature',
-				array( 'content', 'parseinline', 'replaceafter' ),
-				Xml::wrapClass( $this->mSkin->userLink( $comment->mUserID, $comment->mUserText ), 'wl-comment-author' ),
-				$this->mSkin->userTalkLink( $comment->mUserID, $comment->mUserText ),
-				$comment->mUserText
-			);
+			$authorFmt = wfMsgExt( 'wikilog-author-signature', array( 'parseinline' ), $comment->mUserText );
 		} else {
 			$authorPlain = htmlspecialchars( $comment->mAnonName );
 			$authorFmt = wfMsgForContent( 'wikilog-comment-anonsig',
@@ -740,7 +738,7 @@
 			}
 		}
 		if ( $extra ) {
-			$extra = wfMsgForContent( 'parentheses', $wgContLang->pipeList( $extra ) );
+			$extra = implode( ' | ', $extra );
 		} else {
 			$extra = "";
 		}
diff -r 2f012c39365a -r 7c07352c6224 extensions/Wikilog/WikilogFeed.php
--- extensions/Wikilog/WikilogFeed.php
+++ extensions/Wikilog/WikilogFeed.php
@@ -361,7 +361,6 @@
 		if ( !$limit ) $limit = $wgWikilogNumArticles;
 		parent::__construct( $title, $format, $query, $limit );
 		$this->mSiteFeed = $this->mQuery->getWikilogTitle() === null;
-		
 	}
 
 	public function getIndexField() {
@@ -507,7 +506,7 @@
 		# Create new syndication entry.
 		$entry = new WlSyndicationEntry(
 			self::makeEntryId( $itemTitle ),
-			$itemName,
+			( $this->mSiteFeed ? $wikilogName . ' â€” ' : '' ) . $itemName,
 			$row->wlp_updated,
 			$itemTitle->getFullUrl()
 		);
diff -r 2f012c39365a -r 7c07352c6224 extensions/Wikilog/WikilogHooks.php
--- extensions/Wikilog/WikilogHooks.php
+++ extensions/Wikilog/WikilogHooks.php
@@ -57,7 +57,7 @@
 		if ( $title->isTalkPage() ) {
 			# ::WikilogCommentsPage::
 			# Invalidate cache of wikilog item page.
-			if ( $wi->getItemTitle()->exists() ) {
+			if ( $wi->getItemTitle() && $wi->getItemTitle()->exists() ) {
 				$wi->getItemTitle()->invalidateCache();
 				$wi->getItemTitle()->purgeSquid();
 			}
diff -r 2f012c39365a -r 7c07352c6224 extensions/Wikilog/WikilogItemPager.php
--- extensions/Wikilog/WikilogItemPager.php
+++ extensions/Wikilog/WikilogItemPager.php
@@ -498,6 +498,10 @@
 	}
 
 	function getDefaultSort() {
+		global $wgRequest;
+		// A hack to set default sort direction
+		if ( !$wgRequest->getBool( 'asc' ) && ! $wgRequest->getBool( 'desc' ))
+			$wgRequest->setVal('desc', 1);
 		return 'wlp_pubdate';
 	}
 
diff -r 2f012c39365a -r 7c07352c6224 extensions/Wikilog/WikilogUtils.php
--- extensions/Wikilog/WikilogUtils.php
+++ extensions/Wikilog/WikilogUtils.php
@@ -89,7 +89,7 @@
 				: ParserCache::singleton();
 
 			# Look for the parsed article output in the parser cache.
-			$parserOutput = $parserCache->get( $article, $parserOpt );
+			$parserOutput = $parserCache->get( $article, $wgUser );
 
 			# On success, return the object retrieved from the cache.
 			if ( $parserOutput ) {
@@ -123,7 +123,7 @@
 
 		# Save in parser cache.
 		if ( $useParserCache && $parserOutput->getCacheTime() != -1 ) {
-			$parserCache->save( $parserOutput, $article, $parserOpt );
+			$parserCache->save( $parserOutput, $article, $wgUser );
 		}
 
 		# Restore default behavior.
@@ -278,23 +278,36 @@
 			# Parser output contains wikilog output and summary, use it.
 			$summary = Sanitizer::removeHTMLcomments( $parserOutput->mExtWikilog->mSummary );
 		} else {
-			# Try to extract summary from the content text.
-			$blocks = preg_split( '/<(h[1-6]).*?>.*?<\\/\\1>/i', $content, 2 );
-			if ( count( $blocks ) > 1 ) {
-				# Long article with multiple sections, use only the first one.
-				$summary = $blocks[0];
-				# It is possible for the regex to split on a heading that is
-				# not a child of the root element (e.g. <div><h2>...</h2>
-				# </div> leaving an open <div> tag). In order to handle such
-				# cases, we pass the summary through tidy if it is available.
-				if ( $wgUseTidy ) {
-					$summary = MWTidy::tidy( $summary );
+			# Use DOM to extract summary from the content text.
+			try
+			{
+				$dom = new DOMDocument();
+				@$dom->loadHTML('<?xml encoding="UTF-8">' . $content);
+				$summary = new DOMDocument();
+				$h = false;
+				# Dive straight into imported <html><body>
+				foreach ($dom->documentElement->childNodes->item(0)->childNodes as $node)
+				{
+					# Cut summary at first heading
+					if (preg_match('/^h\d$/is', $node->nodeName))
+					{
+						$h = true;
+						break;
+					}
+					if ($node->nodeName == 'table' && $node->attributes->getNamedItem('id')->textContent == 'toc' ||
+						$node->nodeName == 'script')
+						continue;
+					$summary->appendChild($summary->importNode($node, true));
 				}
-			} else {
-				# Short article with a single section, use no summary and
-				# leave to the caller to decide what to do.
+			}
+			catch(Exception $e)
+			{
+				$h = false;
+			}
+			if ($h)
+				$summary = $summary->saveHTML();
+			else
 				$summary = null;
-			}
 		}
 
 		return array( $summary, $content );
