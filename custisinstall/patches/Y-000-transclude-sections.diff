# HG changeset patch
# User Vitaliy Filippov <vitalif@yourcmc.ru>
# Date 1337781188 -14400
Bug 70192 - named section transclusion

diff -r b6139b507754 -r 9e6c051bf491 includes/parser/Parser.php
--- includes/parser/Parser.php
+++ includes/parser/Parser.php
@@ -3103,6 +3103,10 @@
 			$title = Title::newFromText( $part1, $ns );
 			if ( $title ) {
 				$titleText = $title->getPrefixedText();
+				// CustIS Bug 70192 - named section transclusion
+				if ( $frag = $title->getFragment() ) {
+					$titleText .= '#' . $frag;
+				}
 				# Check for language variants if the template is not found
 				if ( $wgContLang->hasVariants() && $title->getArticleID() == 0 ) {
 					$wgContLang->findVariantLink( $part1, $title, true );
@@ -3258,7 +3262,12 @@
 	 */
 	function getTemplateDom( $title ) {
 		$cacheTitle = $title;
+
 		$titleText = $title->getPrefixedDBkey();
+		// CustIS Bug 70192 - named section transclusion
+		if ( $frag = $title->getFragment() ) {
+			$titleText .= '#' . $frag;
+		}
 
 		if ( isset( $this->mTplRedirCache[$titleText] ) ) {
 			list( $ns, $dbk ) = $this->mTplRedirCache[$titleText];
@@ -3278,6 +3287,10 @@
 		}
 
 		$dom = $this->preprocessToDom( $text, self::PTD_FOR_INCLUSION );
+		// CustIS Bug 70192 - named section transclusion
+		if ( $frag ) {
+			$dom = $this->tryExtractNamedSection( $dom, $frag );
+		}
 		$this->mTplDomCache[ $titleText ] = $dom;
 
 		if ( !$title->equals( $cacheTitle ) ) {
@@ -3289,6 +3302,71 @@
 	}
 
 	/**
+	 * CustIS Bug 70192 - try to extract a named section from DOM Document
+	 */
+	function tryExtractNamedSection( $dom, $frag ) {
+		$stack = array( array( $dom->node, 0 ) );
+		$foundlevel = false;
+		$newchild = NULL;
+		$newroot = NULL;
+		$content_started = false;
+		while( $stack ) {
+			$ptr = &$stack[ count( $stack ) - 1 ];
+			if ( $ptr[1] >= $ptr[0]->childNodes->length ) {
+				array_pop( $stack );
+				if ( $foundlevel ) {
+					$newchild = $newchild->parentNode;
+				}
+				continue;
+			}
+			$node = $ptr[0]->childNodes->item( $ptr[1] );
+			$ptr[1]++;
+			if ( !$foundlevel ) {
+				if ( $node->nodeName == 'h' ) {
+					$h = $node->nodeValue;
+					$l = $node->getAttribute( 'level' );
+					$h = trim( substr( $h, $l, -$l ) );
+					if ( $h == $frag ) {
+						$foundlevel = $l;
+						foreach ( $stack as $inside ) {
+							$el = $inside[0]->cloneNode();
+							if ( $newchild ) {
+								$newchild->addChild( $el );
+							} else {
+								$newroot = $el;
+							}
+							$newchild = $el;
+						}
+					}
+				} elseif ( $node->childNodes && $node->childNodes->length ) {
+					$stack[] = array( $node, 0 );
+				}
+			} else {
+				if ( $node->nodeName == 'h' && $node->getAttribute( 'level' ) <= $foundlevel ) {
+					break;
+				}
+				if ( !$content_started && $node->nodeType == XML_TEXT_NODE ) {
+					// left-trim included section
+					$v = ltrim( $node->nodeValue );
+					if ( !$v ) {
+						continue;
+					} else {
+						$newchild->appendChild( $newchild->ownerDocument->createTextNode( $v ) );
+					}
+				} else {
+					$newchild->appendChild( $node->cloneNode( true ) );
+				}
+				$content_started = true;
+			}
+		}
+		unset( $ptr );
+		if ( $newroot ) {
+			$dom = new PPNode_DOM( $newroot );
+		}
+		return $dom;
+	}
+
+	/**
 	 * Fetch the unparsed text of a template and register a reference to it.
 	 * @param Title $title
 	 * @return Array ( string or false, Title )
