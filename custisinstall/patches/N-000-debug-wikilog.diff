# HG changeset patch
# User Vitaliy Filippov <vitali@st-filippov.office.custis.ru>
# Date 1270490251 -14400
Wikilog extension fixes:
Bug 58154 - fix caching error
Bug 56056 - do not handle post subarticles as posts themselves
Bug 61175 - Default sort direction
Bug 61149 - Show wikilog name in site feed
Bug 51595 - Use DOM to extract summary from article content
Bug 61632 - Make comment author signatures using generic mechanism
Bug 61174 - Preview does not get parsed
Bug 61174 - (prerequisite) $query->select(), $query->selectSQLText()
Bug 62314 - Allow to reply from comment page
Bug 62452 - Wikilog does not respect user timezones

diff -r 2f012c39365a -r 238d1fde0c72 extensions/Wikilog/Wikilog.php
--- extensions/Wikilog/Wikilog.php
+++ extensions/Wikilog/Wikilog.php
@@ -423,16 +423,13 @@
 		$ns = MWNamespace::getSubject( $origns );
 		$tns = MWNamespace::getTalk( $origns );
 
-		if ( strpos( $title->getText(), '/' ) !== false ) {
-			# If title contains a '/', treat as a wikilog article title.
-			list( $this->mWikilogName, $this->mItemName ) =
-				explode( '/', $title->getText(), 2 );
-
-			if ( strpos( $this->mItemName, '/' ) !== false ) {
-				list( $this->mItemName, $this->mTrailing ) =
-					explode( '/', $this->mItemName, 2 );
-			}
-
+		# If title contains a '/', treat as a wikilog article title.
+		$parts = explode('/', $title->getText());
+		if (count($parts) > 1 && ($this->mIsTalk || count($parts) == 2))
+		{
+			$this->mWikilogName = array_shift($parts);
+			$this->mItemName = array_shift($parts);
+			$this->mTrailing = implode('/', $parts);
 			$rawtitle = "{$this->mWikilogName}/{$this->mItemName}";
 			$this->mWikilogTitle = Title::makeTitle( $ns, $this->mWikilogName );
 			$this->mItemTitle = Title::makeTitle( $ns, $rawtitle );
diff -r 2f012c39365a -r 238d1fde0c72 extensions/Wikilog/WikilogComment.php
--- extensions/Wikilog/WikilogComment.php
+++ extensions/Wikilog/WikilogComment.php
@@ -612,7 +612,10 @@
 				list( $article, $parserOutput ) = WikilogUtils::parsedArticle( $comment->mCommentTitle );
 				$text = $parserOutput->getText();
 			} else {
+				global $wgParser, $wgUser, $wgTitle;
 				$text = $comment->getText();
+				$text = $wgParser->parse($text, $wgTitle, ParserOptions::newFromUser( $wgUser ));
+				$text = $text->getText();
 			}
 
 			if ( $text ) {
@@ -694,16 +697,11 @@
 	 * @return Array with message parameters.
 	 */
 	public function getCommentMsgParams( $comment ) {
-		global $wgContLang;
+		global $wgLang;
 
 		if ( $comment->mUserID ) {
 			$authorPlain = htmlspecialchars( $comment->mUserText );
-			$authorFmt = wfMsgExt( 'wikilog-simple-signature',
-				array( 'content', 'parseinline', 'replaceafter' ),
-				Xml::wrapClass( $this->mSkin->userLink( $comment->mUserID, $comment->mUserText ), 'wl-comment-author' ),
-				$this->mSkin->userTalkLink( $comment->mUserID, $comment->mUserText ),
-				$comment->mUserText
-			);
+			$authorFmt = wfMsgExt( 'wikilog-author-signature', array( 'parseinline' ), $comment->mUserText );
 		} else {
 			$authorPlain = htmlspecialchars( $comment->mAnonName );
 			$authorFmt = wfMsgForContent( 'wikilog-comment-anonsig',
@@ -713,8 +711,8 @@
 			);
 		}
 
-		$date = $wgContLang->date( $comment->mTimestamp );
-		$time = $wgContLang->time( $comment->mTimestamp );
+		$date = $wgLang->date( $comment->mTimestamp, true );
+		$time = $wgLang->time( $comment->mTimestamp, true );
 		$permalink = $this->getCommentPermalink( $comment, $date, $time );
 
 		$extra = array();
@@ -731,8 +729,8 @@
 				# Comment was edited.
 				$extra[] = $this->mSkin->link( $comment->mCommentTitle,
 					wfMsgForContent( 'wikilog-comment-note-edited',
-						$wgContLang->date( $comment->mUpdated, true ),
-						$wgContLang->time( $comment->mUpdated, true )
+						$wgLang->date( $comment->mUpdated, true ),
+						$wgLang->time( $comment->mUpdated, true )
 					),
 					array( 'title' => wfMsg( 'wikilog-comment-history' ) ),
 					array( 'action' => 'history' ), 'known'
@@ -740,7 +738,7 @@
 			}
 		}
 		if ( $extra ) {
-			$extra = wfMsgForContent( 'parentheses', $wgContLang->pipeList( $extra ) );
+			$extra = implode( ' | ', $extra );
 		} else {
 			$extra = "";
 		}
diff -r 2f012c39365a -r 238d1fde0c72 extensions/Wikilog/WikilogCommentsPage.php
--- extensions/Wikilog/WikilogCommentsPage.php
+++ extensions/Wikilog/WikilogCommentsPage.php
@@ -209,7 +209,7 @@
 		$wgOut->addHtml( $pager->getBody() . $pager->getNavigationBar() );
 
 		# Display "post new comment" form, if appropriate.
-		if ( $this->mUserCanPost && !$replyTo ) {
+		if ( $this->mUserCanPost ) {
 			$wgOut->addHtml( $this->getPostCommentForm( $this->mSingleComment ) );
 		}
 
diff -r 2f012c39365a -r 238d1fde0c72 extensions/Wikilog/WikilogFeed.php
--- extensions/Wikilog/WikilogFeed.php
+++ extensions/Wikilog/WikilogFeed.php
@@ -361,7 +361,6 @@
 		if ( !$limit ) $limit = $wgWikilogNumArticles;
 		parent::__construct( $title, $format, $query, $limit );
 		$this->mSiteFeed = $this->mQuery->getWikilogTitle() === null;
-		
 	}
 
 	public function getIndexField() {
@@ -507,7 +506,7 @@
 		# Create new syndication entry.
 		$entry = new WlSyndicationEntry(
 			self::makeEntryId( $itemTitle ),
-			$itemName,
+			( $this->mSiteFeed ? $wikilogName . ' â€” ' : '' ) . $itemName,
 			$row->wlp_updated,
 			$itemTitle->getFullUrl()
 		);
diff -r 2f012c39365a -r 238d1fde0c72 extensions/Wikilog/WikilogHooks.php
--- extensions/Wikilog/WikilogHooks.php
+++ extensions/Wikilog/WikilogHooks.php
@@ -57,7 +57,7 @@
 		if ( $title->isTalkPage() ) {
 			# ::WikilogCommentsPage::
 			# Invalidate cache of wikilog item page.
-			if ( $wi->getItemTitle()->exists() ) {
+			if ( $wi->getItemTitle() && $wi->getItemTitle()->exists() ) {
 				$wi->getItemTitle()->invalidateCache();
 				$wi->getItemTitle()->purgeSquid();
 			}
diff -r 2f012c39365a -r 238d1fde0c72 extensions/Wikilog/WikilogItem.php
--- extensions/Wikilog/WikilogItem.php
+++ extensions/Wikilog/WikilogItem.php
@@ -163,7 +163,7 @@
 	 * parameters.
 	 */
 	public function getMsgParams( $extended = false, $pout = null ) {
-		global $wgContLang, $wgWikilogEnableTags;
+		global $wgLang, $wgWikilogEnableTags;
 
 		$authors = array_keys( $this->mAuthors );
 		$authorsFmt = WikilogUtils::authorList( $authors );
@@ -208,8 +208,8 @@
 			/* $5  */ count( $authors ),
 			/* $6  */ ( count( $authors ) > 0 ? $authors[0] : '' ),
 			/* $7  */ $authorsFmt,
-			/* $8  */ $wgContLang->date( $this->mPubDate ),
-			/* $9  */ $wgContLang->time( $this->mPubDate ),
+			/* $8  */ $wgLang->date( $this->mPubDate, true ),
+			/* $9  */ $wgLang->time( $this->mPubDate, true ),
 			/* $10 */ $commentsFmt,
 			/* $11 */ count( $categories ),
 			/* $12 */ $categoriesFmt,
diff -r 2f012c39365a -r 238d1fde0c72 extensions/Wikilog/WikilogItemPager.php
--- extensions/Wikilog/WikilogItemPager.php
+++ extensions/Wikilog/WikilogItemPager.php
@@ -296,7 +296,7 @@
 	 * @todo (Req >= Mw 1.16) Remove bug 20431 workaround.
 	 */
 	function formatRow( $row ) {
-		global $wgParser, $wgContLang;
+		global $wgParser, $wgLang;
 
 		# Retrieve article parser output and other data.
 		$item = WikilogItem::newFromRow( $row );
@@ -316,14 +316,14 @@
 		$divclass = 'wl-entry' . ( $item->getIsPublished() ? '' : ' wl-draft' );
 
 		$itemPubdate = $item->getPublishDate();
-		$pubdate = $wgContLang->timeanddate( $itemPubdate, true );
-		$publishedDate = $wgContLang->date( $itemPubdate );
-		$publishedTime = $wgContLang->time( $itemPubdate );
+		$pubdate = $wgLang->timeanddate( $itemPubdate, true );
+		$publishedDate = $wgLang->date( $itemPubdate, true );
+		$publishedTime = $wgLang->time( $itemPubdate, true );
 
 		$itemUpdated = $item->getUpdatedDate();
-		$updated = $wgContLang->timeanddate( $itemUpdated, true );
-		$updatedDate = $wgContLang->date( $itemUpdated );
-		$updatedTime = $wgContLang->time( $itemUpdated );
+		$updated = $wgLang->timeanddate( $itemUpdated, true );
+		$updatedDate = $wgLang->date( $itemUpdated, true );
+		$updatedTime = $wgLang->time( $itemUpdated, true );
 
 		# Template parameters.
 		$vars = array(
@@ -449,11 +449,11 @@
 	}
 
 	function formatValue( $name, $value ) {
-		global $wgContLang;
+		global $wgLang;
 
 		switch ( $name ) {
 			case 'wlp_pubdate':
-				$s = $wgContLang->timeanddate( $value, true );
+				$s = $wgLang->timeanddate( $value, true );
 				if ( !$this->mCurrentRow->wlp_publish ) {
 					$s = Xml::wrapClass( $s, 'wl-draft-inline' );
 				}
@@ -498,6 +498,10 @@
 	}
 
 	function getDefaultSort() {
+		global $wgRequest;
+		// A hack to set default sort direction
+		if ( !$wgRequest->getBool( 'asc' ) && ! $wgRequest->getBool( 'desc' ))
+			$wgRequest->setVal('desc', 1);
 		return 'wlp_pubdate';
 	}
 
diff -r 2f012c39365a -r 238d1fde0c72 extensions/Wikilog/WikilogQuery.php
--- extensions/Wikilog/WikilogQuery.php
+++ extensions/Wikilog/WikilogQuery.php
@@ -141,6 +141,31 @@
 			str_pad( $date_end,   14, '0', STR_PAD_RIGHT )
 		);
 	}
+
+	/* Does $dbr->select with additional conditions taken from this query object */
+	public function select($dbr, $tables, $fields, $conds = array(), $function = __FUNCTION__, $options = array(), $join_conds = array())
+	{
+		return $dbr->query( $this->selectSQLText( $dbr, $tables, $fields, $conds, $function, $options, $join_conds ), $function );
+	}
+
+	/* Does $dbr->selectSQLText with additional conditions taken from this query object */
+	public function selectSQLText($dbr, $tables, $fields, $conds = array(), $function = __FUNCTION__, $options = array(), $join_conds = array())
+	{
+		$info = $this->getQueryInfo( $dbr );
+		if ( $tables )
+			$tables = array_merge( $info['tables'], $tables );
+		else
+			$tables = $info['tables'];
+		if ( $info['conds'] )
+			$conds = array_merge( $info['conds'], $conds );
+		if ( $info['options'] )
+			$options = array_merge( $info['options'], $options );
+		if ( $info['join_conds'] )
+			$join_conds = array_merge( $info['join_conds'], $join_conds );
+		if ( !$fields )
+			$fields = $info['fields'];
+		return $dbr->selectSQLText($tables, $fields, $conds, $function, $options, $join_conds);
+	}
 }
 
 /**
@@ -211,7 +236,7 @@
 	 * @param $category Category title object or text.
 	 */
 	public function setCategory( $category ) {
-		if ( is_object( $category ) ) {
+		if ( is_null( $category ) || is_object( $category ) ) {
 			$this->mCategory = $category;
 		} elseif ( is_string( $category ) ) {
 			$t = Title::makeTitleSafe( NS_CATEGORY, $category );
@@ -226,7 +251,7 @@
 	 * @param $author User page title object or text.
 	 */
 	public function setAuthor( $author ) {
-		if ( is_object( $author ) ) {
+		if ( is_null( $author ) || is_object( $author ) ) {
 			$this->mAuthor = $author;
 		} elseif ( is_string( $author ) ) {
 			$t = Title::makeTitleSafe( NS_USER, $author );
@@ -546,7 +571,7 @@
 	 * @param $author User page title object or text.
 	 */
 	public function setAuthor( $author ) {
-		if ( is_object( $author ) ) {
+		if ( is_null( $author ) || is_object( $author ) ) {
 			$this->mAuthor = $author;
 		} elseif ( is_string( $author ) ) {
 			$t = Title::makeTitleSafe( NS_USER, $author );
diff -r 2f012c39365a -r 238d1fde0c72 extensions/Wikilog/WikilogUtils.php
--- extensions/Wikilog/WikilogUtils.php
+++ extensions/Wikilog/WikilogUtils.php
@@ -89,7 +89,7 @@
 				: ParserCache::singleton();
 
 			# Look for the parsed article output in the parser cache.
-			$parserOutput = $parserCache->get( $article, $parserOpt );
+			$parserOutput = $parserCache->get( $article, $wgUser );
 
 			# On success, return the object retrieved from the cache.
 			if ( $parserOutput ) {
@@ -123,7 +123,7 @@
 
 		# Save in parser cache.
 		if ( $useParserCache && $parserOutput->getCacheTime() != -1 ) {
-			$parserCache->save( $parserOutput, $article, $parserOpt );
+			$parserCache->save( $parserOutput, $article, $wgUser );
 		}
 
 		# Restore default behavior.
@@ -278,23 +278,36 @@
 			# Parser output contains wikilog output and summary, use it.
 			$summary = Sanitizer::removeHTMLcomments( $parserOutput->mExtWikilog->mSummary );
 		} else {
-			# Try to extract summary from the content text.
-			$blocks = preg_split( '/<(h[1-6]).*?>.*?<\\/\\1>/i', $content, 2 );
-			if ( count( $blocks ) > 1 ) {
-				# Long article with multiple sections, use only the first one.
-				$summary = $blocks[0];
-				# It is possible for the regex to split on a heading that is
-				# not a child of the root element (e.g. <div><h2>...</h2>
-				# </div> leaving an open <div> tag). In order to handle such
-				# cases, we pass the summary through tidy if it is available.
-				if ( $wgUseTidy ) {
-					$summary = MWTidy::tidy( $summary );
+			# Use DOM to extract summary from the content text.
+			try
+			{
+				$dom = new DOMDocument();
+				@$dom->loadHTML('<?xml encoding="UTF-8">' . $content);
+				$summary = new DOMDocument();
+				$h = false;
+				# Dive straight into imported <html><body>
+				foreach ($dom->documentElement->childNodes->item(0)->childNodes as $node)
+				{
+					# Cut summary at first heading
+					if (preg_match('/^h\d$/is', $node->nodeName))
+					{
+						$h = true;
+						break;
+					}
+					if ($node->nodeName == 'table' && $node->attributes->getNamedItem('id')->textContent == 'toc' ||
+						$node->nodeName == 'script')
+						continue;
+					$summary->appendChild($summary->importNode($node, true));
 				}
-			} else {
-				# Short article with a single section, use no summary and
-				# leave to the caller to decide what to do.
+			}
+			catch(Exception $e)
+			{
+				$h = false;
+			}
+			if ($h)
+				$summary = $summary->saveHTML();
+			else
 				$summary = null;
-			}
 		}
 
 		return array( $summary, $content );
