Index: includes/filerepo/LocalFile.php
===================================================================
--- includes/filerepo/LocalFile.php	(revision 54846)
+++ includes/filerepo/LocalFile.php	(working copy)
@@ -764,6 +764,66 @@ class LocalFile extends File
 	}
 
 	/**
+	 * Upload a file directly into archive. Generally for Special:Import
+	 */
+	function uploadIntoArchive( $srcPath, $comment, $pageText, $flags = 0, $props = false, $timestamp = false )
+	{
+		$this->lock();
+		$dstName = gmdate( 'YmdHis', wfTimestamp( TS_UNIX, $timestamp ) ) . '!' . $this->getPhys();
+		$status = $this->publish( $srcPath, $flags, $dstName );
+		if ( $status->ok ) {
+			if ( !$this->recordOldUpload( $dstName, $comment, $pageText, $props, $timestamp ) ) {
+				$status->fatal( 'filenotfound', $srcPath );
+			}
+		}
+		$this->unlock();
+		return $status;
+	}
+
+	/**
+	 * Record a file upload in the upload log and the oldimage table
+	 */
+	function recordOldUpload( $dstName, $comment, $pageText, $props = false, $timestamp = false )
+	{
+		global $wgUser;
+
+		$dbw = $this->repo->getMasterDB();
+
+		$dstPath = $this->repo->getZonePath('public') . '/archive/' . $this->getHashPath() . $dstName;
+		$props = self::getPropsFromPath( $dstPath );
+		if (!$props['fileExists'])
+			return false;
+
+		$props['timestamp'] = wfTimestamp( TS_MW, $timestamp );
+		list($props['major_mime'], $props['minor_mime']) =
+			self::splitMime( "{$props['major_mime']}/{$props['minor_mime']}" );
+
+		$dbw->insert( 'oldimage',
+			array(
+				'oi_name'         => $this->getName(),
+				'oi_archive_name' => $dstName,
+				'oi_size'         => $props['size'],
+				'oi_width'        => intval($props['width']),
+				'oi_height'       => intval($props['height']),
+				'oi_bits'         => $props['bits'],
+				'oi_timestamp'    => $props['timestamp'],
+				'oi_description'  => $comment,
+				'oi_user'         => $wgUser->getId(),
+				'oi_user_text'    => $wgUser->getName(),
+				'oi_metadata'     => $props['metadata'],
+				'oi_media_type'   => $props['media_type'],
+				'oi_major_mime'   => $props['major_mime'],
+				'oi_minor_mime'   => $props['minor_mime'],
+				'oi_sha1'         => $props['sha1'],
+			), __METHOD__
+		);
+
+		$dbw->immediateCommit();
+
+		return true;
+	}
+
+	/**
 	 * Record a file upload in the upload log and the image table
 	 */
 	function recordUpload2( $oldver, $comment, $pageText, $props = false, $timestamp = false )
@@ -929,15 +989,21 @@ class LocalFile extends File
 	 *
 	 * @param string $sourcePath Local filesystem path to the source image
 	 * @param integer $flags A bitwise combination of:
-	 *     File::DELETE_SOURCE    Delete the source file, i.e. move
-	 *         rather than copy
+	 *     File::DELETE_SOURCE       Delete the source file, i.e. move rather than copy
+	 * @param string $dstName Local wanted path (for example some archive
+	 *        path to publish image into the archive directly)
 	 * @return FileRepoStatus object. On success, the value member contains the
 	 *     archive name, or an empty string if it was a new file.
 	 */
-	function publish( $srcPath, $flags = 0 ) {
+	function publish( $srcPath, $flags = 0, $dstName = NULL ) {
 		$this->lock();
+		if (!$dstName)
 		$dstRel = $this->getRel();
-		$archiveName = gmdate( 'YmdHis' ) . '!'. $this->getPhys();
+		else
+			$dstRel = 'archive/' . $this->getHashPath() . $dstName;
+		# Изначальное gmdate( 'YmdHis' ) - это НИФИГА не правильно!
+		# Получается, что в имени файла один timestamp, а в базе другой...
+		$archiveName = gmdate( 'YmdHis', wfTimestamp( TS_UNIX, $this->getTimestamp() ) ) . '!'. $this->getPhys();
 		$archiveRel = 'archive/' . $this->getHashPath() . $archiveName;
 		$flags = $flags & File::DELETE_SOURCE ? LocalRepo::DELETE_SOURCE : 0;
 		$status = $this->repo->publish( $srcPath, $dstRel, $archiveRel, $flags );
Index: includes/specials/SpecialExport.php
===================================================================
--- includes/specials/SpecialExport.php	(revision 58851)
+++ includes/specials/SpecialExport.php	(working copy)
@@ -105,13 +105,6 @@
 }
 
 /**
- * Callback function to remove empty strings from the pages array.
- */
-function wfFilterPage( $page ) {
-	return $page !== '' && $page !== null;
-}
-
-/**
  *
  */
 function wfSpecialExport( $page = '' ) {
@@ -205,19 +198,20 @@
 		}
 
 		/* Split up the input and look up linked pages */
-		$inputPages = array_filter( explode( "\n", $page ), 'wfFilterPage' );
+		$inputPages = array();
+		foreach (explode("\n", $page) as $p)
+			if ($p !== '' && $p !== null)
+				$inputPages[] = Title::newFromText($p)->getPrefixedText();
 		$pageSet = array_flip( $inputPages );
 
 		if( $wgRequest->getCheck( 'templates' ) ) {
 			$pageSet = wfExportGetTemplates( $inputPages, $pageSet );
 		}
 
-		/*
 		// Enable this when we can do something useful exporting/importing image information. :)
 		if( $wgRequest->getCheck( 'images' ) ) {
 			$pageSet = wfExportGetImages( $inputPages, $pageSet );
 		}
-		*/
 
 		$pages = array_keys( $pageSet );
 
@@ -241,6 +235,8 @@
 
 		$exporter = new WikiExporter( $db, $history, $buffer );
 		$exporter->list_authors = $list_authors ;
+		$exporter->dumpUploads = $wgRequest->getCheck('images') ? true : false;
+		$exporter->selfContained = $wgRequest->getCheck('selfcontained') ? true : false;
 		$exporter->openStream();
 
 		foreach( $pages as $page ) {
@@ -287,13 +283,14 @@
 	$form .= '<br />';
 
 	if( $wgExportAllowHistory ) {
-		$form .= Xml::checkLabel( wfMsg( 'exportcuronly' ), 'curonly', 'curonly', true ) . '<br />';
+		$form .= Xml::checkLabel( wfMsg( 'exportcuronly' ), 'curonly', 'curonly', $wgRequest->getCheck('curonly') ? true : false ) . '<br />';
 	} else {
 		$wgOut->addHTML( wfMsgExt( 'exportnohistory', 'parse' ) );
 	}
-	$form .= Xml::checkLabel( wfMsg( 'export-templates' ), 'templates', 'wpExportTemplates', false ) . '<br />';
+	$form .= Xml::checkLabel( wfMsg( 'export-templates' ), 'templates', 'wpExportTemplates', $wgRequest->getCheck('templates') ? true : false ) . '<br />';
 	// Enable this when we can do something useful exporting/importing image information. :)
-	//$form .= Xml::checkLabel( wfMsg( 'export-images' ), 'images', 'wpExportImages', false ) . '<br />';
+	$form .= Xml::checkLabel( wfMsg( 'export-images' ), 'images', 'wpExportImages', $wgRequest->getCheck('images') ? true : false ) . '<br />';
+	$form .= Xml::checkLabel( wfMsg( 'export-selfcontained' ), 'selfcontained', 'wpSelfContained', $wgRequest->getCheck('selfcontained') ? true : false ) . '<br />';
 	$form .= Xml::checkLabel( wfMsg( 'export-download' ), 'wpDownload', 'wpDownload', true ) . '<br />';
 
 	$form .= Xml::submitButton( wfMsg( 'export-submit' ), array( 'accesskey' => 's' ) );
Index: includes/specials/SpecialImport.php
===================================================================
--- includes/specials/SpecialImport.php	(revision 58865)
+++ includes/specials/SpecialImport.php	(working copy)
@@ -264,7 +264,9 @@
 		$wgOut->addHTML( "<ul>\n" );
 	}
 
-	function reportPage( $title, $origTitle, $revisionCount, $successCount ) {
+	function reportPage( $title, $origTitle, $revisionCount, $successCount,
+		$lastExistingRevision, $lastLocalRevision, $lastRevision )
+	{
 		global $wgOut, $wgUser, $wgLang, $wgContLang;
 
 		$skin = $wgUser->getSkin();
@@ -274,12 +276,56 @@
 		$localCount = $wgLang->formatNum( $successCount );
 		$contentCount = $wgContLang->formatNum( $successCount );
 
+		/* No revisions in import */
+		if (!$lastExistingRevision && $successCount == 0)
+			$msg = wfMsgHtml('import-norevisions');
+
+		/* New page imported */
+		else if (!$lastLocalRevision && $successCount > 0)
+			$msg = wfMsgExt('import-revision-count-newpage', array('parsemag', 'escape'), $localCount);
+
+		else
+		{
+			$newer = !$lastExistingRevision ||
+				$lastLocalRevision->getTimestamp() > $lastExistingRevision->getTimestamp();
+			if ($successCount > 0)
+			{
+				/* Conflict */
+				if ($newer)
+				{
+					$linktext = wfMsgExt( 'import-conflict-difflink',
+						array( 'parsemag', 'escape' ),
+						$lastRevision->getId(),
+						$lastLocalRevision->getId() );
+					$link = $skin->makeKnownLinkObj(
+						$title, $linktext,
+						'diff=' . $lastRevision->getId() .
+						"&oldid=" . $lastLocalRevision->getId() );
+					$msg = wfMsgExt( 'import-conflict',
+						array( 'parsemag' ),
+						$localCount,
+						$link );
+				}
+				/* Page history continued with new revisions */
+				else
+					$msg = wfMsgExt('import-revision-count', array('parsemag', 'escape'), $localCount);
+			}
+			else
+			{
+				/* Local revision is newer */
+				if ($newer)
+					$msg = wfMsgHtml('import-nonewrevisions-localnewer');
+				/* No changes nowhere */
+				else
+					$msg = wfMsgHtml('import-nonewrevisions');
+			}
+		}
+
+		$msg = $skin->makeKnownLinkObj( $title ) . ': ' . $msg;
+
+		$wgOut->addHtml( "<li>$msg</li>" );
+
 		if( $successCount > 0 ) {
-			$wgOut->addHTML( "<li>" . $skin->makeKnownLinkObj( $title ) . " " .
-				wfMsgExt( 'import-revision-count', array( 'parsemag', 'escape' ), $localCount ) .
-				"</li>\n"
-			);
-
 			$log = new LogPage( 'import' );
 			if( $this->mIsUpload ) {
 				$detail = wfMsgExt( 'import-logentry-upload-detail', array( 'content', 'parsemag' ),
@@ -308,8 +354,6 @@
 			# Update page record
 			$article->updateRevisionOn( $dbw, $nullRevision );
 			wfRunHooks( 'NewRevisionFromEditComplete', array($article, $nullRevision, $latest, $wgUser) );
-		} else {
-			$wgOut->addHTML( '<li>' . wfMsgHtml( 'import-nonewrevisions' ) . '</li>' );
 		}
 	}
 
Index: includes/Export.php
===================================================================
--- includes/Export.php	(revision 58851)
+++ includes/Export.php	(working copy)
@@ -28,7 +28,8 @@
 	var $list_authors = false ; # Return distinct author list (when not returning full history)
 	var $author_list = "" ;
 
-	var $dumpUploads = false;
+	var $dumpUploads = false;   # Dump uploaded files into the export file
+	var $selfContained = false; # Make export file self-contained (multipart/related)
 
 	const FULL = 0;
 	const CURRENT = 1;
@@ -77,6 +78,7 @@
 	}
 
 	public function openStream() {
+		$this->writer->multipart = $this->dumpUploads && $this->selfContained;
 		$output = $this->writer->openStream();
 		$this->sink->writeOpenStream( $output );
 	}
@@ -84,6 +86,9 @@
 	public function closeStream() {
 		$output = $this->writer->closeStream();
 		$this->sink->writeCloseStream( $output );
+		/* Dump $this->writer->binaries into multipart/related */
+		while ($part = $this->writer->nextPart())
+			$this->sink->writePart($part);
 	}
 
 	/**
@@ -293,7 +298,8 @@
 				if( isset( $last ) ) {
 					$output = '';
 					if( $this->dumpUploads ) {
-						$output .= $this->writer->writeUploads( $last );
+						$output .= $this->writer->writeUploads( $last,
+							$this->history == WikiExporter::CURRENT ? 1 : null );
 					}
 					$output .= $this->writer->closePage();
 					$this->sink->writeClosePage( $output );
@@ -308,7 +314,8 @@
 		if( isset( $last ) ) {
 			$output = '';
 			if( $this->dumpUploads ) {
-				$output .= $this->writer->writeUploads( $last );
+				$output .= $this->writer->writeUploads( $last,
+					$this->history == WikiExporter::CURRENT ? 1 : null );
 			}
 			$output .= $this->author_list;
 			$output .= $this->writer->closePage();
@@ -331,6 +338,10 @@
  */
 class XmlDumpWriter {
 
+	var $boundary;
+	var $binaries;
+	var $multipart;
+
 	/**
 	 * Returns the export schema version.
 	 * @return string
@@ -352,7 +363,15 @@
 	function openStream() {
 		global $wgContLanguageCode;
 		$ver = $this->schemaVersion();
-		return Xml::element( 'mediawiki', array(
+		$mp = '';
+		if ($this->multipart)
+		{
+			$this->boundary = '--'.time();
+			$this->binaries = array();
+			$mp = "Content-Type: multipart/related; boundary=".$this->boundary."\n".$this->boundary."\nContent-Type: text/xml\nContent-ID: Revisions\n\n";
+		}
+		return $mp .
+			Xml::element( 'mediawiki', array(
 			'xmlns'              => "http://www.mediawiki.org/xml/export-$ver/",
 			'xmlns:xsi'          => "http://www.w3.org/2001/XMLSchema-instance",
 			'xsi:schemaLocation' => "http://www.mediawiki.org/xml/export-$ver/ " .
@@ -415,6 +434,22 @@
 		return "</mediawiki>\n";
 	}
 
+	function nextPart() {
+		if ($this->multipart && count($this->binaries) > 0)
+		{
+			list($name) = array_keys($this->binaries);
+			$data = $this->binaries[$name];
+			unset($this->binaries[$name]);
+			$data = @file_get_contents($data);
+			return $this->boundary.
+				"\nContent-Type: application/binary\n" .
+				"Content-Transfer-Encoding: Little-Endian\n" .
+				"Content-ID: $name\n" .
+				"Content-Length: ".strlen($data)."\n\n" .
+				$data;
+		}
+		return '';
+	}
 
 	/**
 	 * Opens a <page> section on the output stream, with data
@@ -482,7 +517,9 @@
 		} elseif( isset( $row->old_text ) ) {
 			// Raw text from the database may have invalid chars
 			$text = strval( Revision::getRevisionText( $row ) );
-			$out .= "      " . Xml::elementClean( 'text',
+			// Remove "export cuts"
+			$text = preg_replace( '/<!--\s*begindsp\s*\@?\s*-->.*?<!--\s*enddsp\s*\@?\s*-->/is', '', $text );
+			$out .= "      " . Xml::ElementClean( 'text',
 				array( 'xml:space' => 'preserve' ),
 				strval( $text ) ) . "\n";
 		} else {
@@ -566,12 +603,12 @@
 	/**
 	 * Warning! This data is potentially inconsistent. :(
 	 */
-	function writeUploads( $row ) {
+	function writeUploads( $row, $limit = null ) {
 		if( $row->page_namespace == NS_IMAGE ) {
 			$img = wfFindFile( $row->page_title );
 			if( $img ) {
 				$out = '';
-				foreach( array_reverse( $img->getHistory() ) as $ver ) {
+				foreach( $img->getHistory($limit) as $ver ) {
 					$out .= $this->writeUpload( $ver );
 				}
 				$out .= $this->writeUpload( $img );
@@ -582,13 +619,20 @@
 	}
 
 	function writeUpload( $file ) {
+		if ($this->multipart)
+		{
+			$partname = $file->isOld() ? $file->getArchiveName() : $file->getName();
+			$this->binaries[$partname] = $file->getPath();
+		}
 		return "    <upload>\n" .
 			$this->writeTimestamp( $file->getTimestamp() ) .
 			$this->writeContributor( $file->getUser( 'id' ), $file->getUser( 'text' ) ) .
-			"      " . Xml::elementClean( 'comment', null, $file->getDescription() ) . "\n" .
-			"      " . Xml::element( 'filename', null, $file->getName() ) . "\n" .
-			"      " . Xml::element( 'src', null, $file->getFullUrl() ) . "\n" .
-			"      " . Xml::element( 'size', null, $file->getSize() ) . "\n" .
+			"      " . Xml::ElementClean( 'comment', null, $file->getDescription() ) . "\n" .
+			"      " . Xml::Element( 'filename', null, $file->getName() ) . "\n" .
+			"      " . Xml::Element( 'src',
+			                      array('sha1' => $file->getSha1()),
+			                      $partname ? "multipart://$partname" : $file->getFullUrl() ) . "\n" .
+			"      " . Xml::Element( 'size', null, $file->getSize() ) . "\n" .
 			"    </upload>\n";
 	}
 
@@ -624,6 +668,10 @@
 		$this->write( $string );
 	}
 
+	function writePart( $string ) {
+		$this->write( $string );
+	}
+
 	/**
 	 * Override to write to a different stream type.
 	 * @return bool
Index: includes/Import.php
===================================================================
--- includes/Import.php	(revision 58851)
+++ includes/Import.php	(working copy)
@@ -87,6 +87,10 @@
 		$this->filename = $filename;
 	}
 
+	function setSha1( $sha1 ) {
+		$this->sha1 = trim( $sha1 );
+	}
+
 	function setSize( $size ) {
 		$this->size = intval( $size );
 	}
@@ -139,6 +143,10 @@
 		return $this->filename;
 	}
 
+	function getSha1() {
+		return $this->sha1;
+	}
+
 	function getSize() {
 		return $this->size;
 	}
@@ -181,7 +189,7 @@
 		} else {
 			$created = false;
 
-			$prior = $dbw->selectField( 'revision', '1',
+			$prior = $dbw->selectField( 'revision', 'rev_id',
 				array( 'rev_page' => $pageId,
 					'rev_timestamp' => $dbw->timestamp( $this->timestamp ),
 					'rev_user_text' => $userText,
@@ -189,10 +197,11 @@
 				__METHOD__
 			);
 			if( $prior ) {
+				$prior = Revision::newFromId( $prior );
 				// FIXME: this could fail slightly for multiple matches :P
 				wfDebug( __METHOD__ . ": skipping existing revision for [[" .
 					$this->title->getPrefixedText() . "]], timestamp " . $this->timestamp . "\n" );
-				return false;
+				return $prior;
 			}
 		}
 
@@ -235,7 +244,9 @@
 		}
 		$GLOBALS['wgTitle'] = $tempTitle;
 
-		return true;
+		# A hack. TOdo it better?
+		$revision->_imported = true;
+		return $revision;
 	}
 	
 	function importLogItem() {
@@ -281,29 +292,10 @@
 		$dbw->insert( 'logging', $data, __METHOD__ );
 	}
 
-	function importUpload() {
+	function importUpload()
+	{
 		wfDebug( __METHOD__ . ": STUB\n" );
 
-		/**
-			// from file revert...
-			$source = $this->file->getArchiveVirtualUrl( $this->oldimage );
-			$comment = $wgRequest->getText( 'wpComment' );
-			// TODO: Preserve file properties from database instead of reloading from file
-			$status = $this->file->upload( $source, $comment, $comment );
-			if( $status->isGood() ) {
-		*/
-
-		/**
-			// from file upload...
-		$this->mLocalFile = wfLocalFile( $nt );
-		$this->mDestName = $this->mLocalFile->getName();
-		//....
-			$status = $this->mLocalFile->upload( $this->mTempPath, $this->mComment, $pageText,
-			File::DELETE_SOURCE, $this->mFileProps );
-			if ( !$status->isGood() ) {
-				$resultDetails = array( 'internal' => $status->getWikiText() );
-		*/
-
 		// @fixme upload() uses $wgUser, which is wrong here
 		// it may also create a page without our desire, also wrong potentially.
 		// and, it will record a *current* upload, but we might want an archive version here
@@ -315,26 +307,67 @@
 			return false;
 		}
 
+		/* First check if file already exists */
+		if ($file->exists())
+		{
+			/* Backward-compatibility: support export files without sha1 */
+			if ($this->getSha1() && $file->getSha1() == $this->getSha1() ||
+				!$this->getSha1() && $file->getTimestamp() == $this->getTimestamp())
+			{
+				wfDebug( "IMPORT: File already exists and is equal to imported (".$this->getTimestamp().").\n" );
+				return false;
+			}
+			$history = $file->getHistory(null, $this->getTimestamp(), $this->getTimestamp());
+			foreach ($history as $oldfile)
+			{
+				if (!$this->getSha1() || $oldfile->getSha1() == $this->getSha1())
+				{
+					wfDebug( "IMPORT: File revision already exists at its timestamp (".$this->getTimestamp().") and is equal to imported.\n" );
+					return false;
+				}
+			}
+		}
+
+		/* Get file source into a temporary file */
 		$source = $this->downloadSource();
 		if( !$source ) {
 			wfDebug( "IMPORT: Could not fetch remote file. :(\n" );
 			return false;
 		}
 
-		$status = $file->upload( $source,
-			$this->getComment(),
-			$this->getComment(), // Initial page, if none present...
-			File::DELETE_SOURCE,
-			false, // props...
-			$this->getTimestamp() );
+		// @fixme upload() uses $wgUser, which is wrong here
+		// it may also create a page without our desire, also wrong potentially.
 
+		if ($file->exists() && $file->getTimestamp() > $this->getTimestamp())
+		{
+			/* Upload an *archive* version */
+			wfDebug( "Importing an archive $arch version of file (".$this->getTimestamp().")\n" );
+			$status = $file->uploadIntoArchive( $source,
+				$this->getComment(),
+				$this->getComment(), // Initial page, if none present...
+				File::DELETE_SOURCE,
+				false, // props...
+				$this->getTimestamp() );
+		}
+		else
+		{
+			wfDebug( "Importing a new current version of file (".$this->getTimestamp().")\n" );
+			/* Upload a *current* version */
+			$status = $file->upload( $source,
+				$this->getComment(),
+				$this->getComment(), // Initial page, if none present...
+				File::DELETE_SOURCE,
+				false, // props...
+				$this->getTimestamp() );
+		}
+
 		if( $status->isGood() ) {
 			// yay?
-			wfDebug( "IMPORT: is ok?\n" );
+			wfDebug( "IMPORT: file imported OK\n" );
 			return true;
 		}
 
-		wfDebug( "IMPORT: is bad? " . $status->getXml() . "\n" );
+		wfDebug( "IMPORT: file import FAILED: " . $status->getXml() . "\n" );
 		return false;
 
 	}
@@ -345,6 +378,12 @@
 			return false;
 		}
 
+		/* Если файл прикреплён как multipart-часть, вернём его */
+		$src = $this->getSrc();
+		if (is_file( $src ))
+			return $src;
+
+		/* Иначе нужно заморочиться и скачать... */
 		$tempo = tempnam( wfTempDir(), 'download' );
 		$f = fopen( $tempo, 'wb' );
 		if( !$f ) {
@@ -353,7 +392,6 @@
 		}
 
 		// @fixme!
-		$src = $this->getSrc();
 		$data = Http::get( $src );
 		if( !$data ) {
 			wfDebug( "IMPORT: couldn't fetch source $src\n" );
@@ -390,6 +428,7 @@
 	function __construct( $source ) {
 		$this->setRevisionCallback( array( $this, "importRevision" ) );
 		$this->setUploadCallback( array( $this, "importUpload" ) );
+		$this->setPageCallback( array( $this, "beginPage" ) );
 		$this->setLogItemCallback( array( $this, "importLogItem" ) );
 		$this->mSource = $source;
 	}
@@ -408,11 +447,11 @@
 
 	function stripXmlNamespace($name) {
 		if( $this->mXmlNamespace ) {
-	               return(preg_replace($this->mXmlNamespace,'',$name,1));
+			return(preg_replace($this->mXmlNamespace,'',$name,1));
 		}
 		else {
-		       return($name);
-                }
+			return($name);
+		}
 	}
    
 	# --------------
@@ -563,12 +602,13 @@
 	}
 
 	/**
-	 * Dummy for now...
+	 * Per-revision file import callback, performs the upload.
+	 * @param $revision WikiRevision
+	 * @private
 	 */
 	function importUpload( $revision ) {
-		//$dbw = wfGetDB( DB_MASTER );
-		//return $dbw->deadlockLoop( array( $revision, 'importUpload' ) );
-		return false;
+		$dbw = wfGetDB( DB_MASTER );
+		return $dbw->deadlockLoop( array( $revision, 'importUpload' ) );
 	}
 
 	/**
@@ -606,12 +646,15 @@
 	 * @param $origTitle Title
 	 * @param $revisionCount int
 	 * @param $successCount Int: number of revisions for which callback returned true
+	 * @param $lastExistingRevision Revision
+	 * @param $lastLocalRevision Revision
+	 * @param $lastRevision Revision
 	 * @private
 	 */
-	function pageOutCallback( $title, $origTitle, $revisionCount, $successCount ) {
+	function pageOutCallback() {
 		if( is_callable( $this->mPageOutCallback ) ) {
-			call_user_func( $this->mPageOutCallback, $title, $origTitle,
-				$revisionCount, $successCount );
+			$args = func_get_args();
+			call_user_func_array( $this->mPageOutCallback, $args );
 		}
 	}
 
@@ -621,7 +664,7 @@
 	}
 
 	function in_start( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_start $name" );
 		if( $name != "mediawiki" ) {
 			return $this->throwXMLerror( "Expected <mediawiki>, got <$name>" );
@@ -630,7 +673,7 @@
 	}
 
 	function in_mediawiki( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_mediawiki $name" );
 		if( $name == 'siteinfo' ) {
 			xml_set_element_handler( $parser, "in_siteinfo", "out_siteinfo" );
@@ -640,6 +683,9 @@
 			$this->workSuccessCount = 0;
 			$this->uploadCount = 0;
 			$this->uploadSuccessCount = 0;
+			$this->lastRevision = NULL;
+			$this->lastLocalRevision = NULL;
+			$this->lastExistingRevision = NULL;
 			xml_set_element_handler( $parser, "in_page", "out_page" );
 		} elseif( $name == 'logitem' ) {
 			$this->push( $name );
@@ -650,7 +696,7 @@
 		}
 	}
 	function out_mediawiki( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_mediawiki $name" );
 		if( $name != "mediawiki" ) {
 			return $this->throwXMLerror( "Expected </mediawiki>, got </$name>" );
@@ -661,7 +707,7 @@
 
 	function in_siteinfo( $parser, $name, $attribs ) {
 		// no-ops for now
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_siteinfo $name" );
 		switch( $name ) {
 		case "sitename":
@@ -677,15 +723,37 @@
 	}
 
 	function out_siteinfo( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		if( $name == "siteinfo" ) {
 			xml_set_element_handler( $parser, "in_mediawiki", "out_mediawiki" );
 		}
 	}
 
+	function beginPage( $title )
+	{
+		$fields = Revision::selectFields();
+		$fields[] = 'page_namespace';
+		$fields[] = 'page_title';
+		$fields[] = 'page_latest';
+		$dbr = wfGetDB( DB_MASTER );
+		$res = $dbr->select(
+			array( 'page', 'revision' ),
+			$fields,
+			array( 'page_id=rev_page',
+			       'page_namespace' => $this->pageTitle->getNamespace(),
+			       'page_title'     => $this->pageTitle->getDBkey(),
+			       'rev_len IS NOT NULL' ),
+			'Revision::fetchRow',
+			array( 'LIMIT' => 1,
+			       'ORDER BY' => 'rev_timestamp DESC' ) );
+		$row = $res->fetchObject();
+		$res->free();
+		if ($row)
+			$this->lastLocalRevision = new Revision( $row );
+	}
 
 	function in_page( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_page $name" );
 		switch( $name ) {
 		case "id":
@@ -726,7 +794,7 @@
 	}
 
 	function out_page( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_page $name" );
 		$this->pop();
 		if( $name != "page" ) {
@@ -735,7 +803,9 @@
 		xml_set_element_handler( $parser, "in_mediawiki", "out_mediawiki" );
 
 		$this->pageOutCallback( $this->pageTitle, $this->origTitle,
-			$this->workRevisionCount, $this->workSuccessCount );
+			$this->workRevisionCount, $this->workSuccessCount,
+			$this->lastExistingRevision, $this->lastLocalRevision,
+			$this->lastRevision );
 
 		$this->workTitle = null;
 		$this->workRevision = null;
@@ -746,7 +816,7 @@
 	}
 
 	function in_nothing( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_nothing $name" );
 		return $this->throwXMLerror( "No child elements allowed here; got <$name>" );
 	}
@@ -757,7 +827,7 @@
 	}
 
 	function out_append( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_append $name" );
 		if( $name != $this->appendfield ) {
 			return $this->throwXMLerror( "Expected </{$this->appendfield}>, got </$name>" );
@@ -835,7 +905,15 @@
 			break;
 		case "src":
 			if( $this->workRevision )
+			{
+				/* Передаём путь к файлу, если он уже загружен */
+				if (substr($this->appenddata, 0, 12) == 'multipart://' &&
+				    ($p = $this->mSource->parts[substr($this->appenddata, 12)]))
+					$this->workRevision->setSrc($p['tempfile']);
+				/* Иначе передаём URL */
+				else
 				$this->workRevision->setSrc( $this->appenddata );
+			}
 			break;
 		case "size":
 			if( $this->workRevision )
@@ -853,7 +931,7 @@
 	}
 
 	function in_revision( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_revision $name" );
 		switch( $name ) {
 		case "id":
@@ -875,7 +953,7 @@
 	}
 
 	function out_revision( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_revision $name" );
 		$this->pop();
 		if( $name != "revision" ) {
@@ -886,14 +964,17 @@
 		if( $this->workRevision ) {
 			$ok = call_user_func_array( $this->mRevisionCallback,
 				array( $this->workRevision, $this ) );
-			if( $ok ) {
+			if( is_object($ok) && $ok->_imported ) {
+				$this->lastRevision = $ok;
 				$this->workSuccessCount++;
-			}
+			} else if ( is_object($ok) && ( !$this->lastExistingRevision ||
+				$ok->getTimestamp() > $this->lastExistingRevision->getTimestamp() ) )
+				$this->lastExistingRevision = $ok;
 		}
 	}
 	
 	function in_logitem( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_logitem $name" );
 		switch( $name ) {
 		case "id":
@@ -917,7 +998,7 @@
 	}
 
 	function out_logitem( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_logitem $name" );
 		$this->pop();
 		if( $name != "logitem" ) {
@@ -935,7 +1016,7 @@
 	}
 
 	function in_upload( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_upload $name" );
 		switch( $name ) {
 		case "timestamp":
@@ -943,6 +1024,8 @@
 		case "text":
 		case "filename":
 		case "src":
+			if ($this->workRevision && $attribs['sha1'])
+				$this->workRevision->setSha1( $attribs['sha1'] );
 		case "size":
 			$this->appendfield = $name;
 			xml_set_element_handler( $parser, "in_nothing", "out_append" );
@@ -958,7 +1041,7 @@
 	}
 
 	function out_upload( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_revision $name" );
 		$this->pop();
 		if( $name != "upload" ) {
@@ -976,7 +1059,7 @@
 	}
 
 	function in_contributor( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_contributor $name" );
 		switch( $name ) {
 		case "username":
@@ -992,7 +1075,7 @@
 	}
 
 	function out_contributor( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_contributor $name" );
 		$this->pop();
 		if( $name != "contributor" ) {
@@ -1043,6 +1126,10 @@
 			return $this->mString;
 		}
 	}
+
+	function nextPart() {
+		return false;
+	}
 }
 
 /**
@@ -1050,20 +1137,131 @@
  * @ingroup SpecialPage
  */
 class ImportStreamSource {
-	function __construct( $handle ) {
+
+	var $buf;
+	var $eop;
+	var $boundary;
+
+	const BUF_SIZE = 65536;
+
+	function __construct( $handle )
+	{
 		$this->mHandle = $handle;
+		$this->eop = false;
+		$this->buf = '';
+		$this->boundary = '';
+		$pos = ftell($this->mHandle);
+		$s = fgets($this->mHandle);
+		/* multipart-файл? */
+		if (preg_match("/Content-Type:\s*multipart\/related; boundary=([^\r\n]+)\r*\n/s", $s, $m))
+		{
+			$this->boundary = $m[1];
+			$this->parts = array();
+			/* Распаковываем файл на части.
+			 * Смысл в том, что процедура импорта загруженных файлов
+			 * должна видеть части. Но они идут после XML-файла в multipart
+			 * документе. Точнее, в принципе, в произвольном месте.
+			 */
+			while (!feof($this->mHandle))
+			{
+				$s = trim(fgets($this->mHandle));
+				if ($s != $this->boundary)
+					break;
+				$part = array();
+				/* Читаем заголовки */
+				while ($s != "\n" && $s != "\r\n")
+				{
+					$s = fgets($this->mHandle);
+					if (preg_match('/([a-z0-9\-\_]+):\s*(.*?)\s*$/is', $s, $m))
+						$part[str_replace('-','_',strtolower($m[1]))] = $m[2];
+				}
+				/* Читаем данные */
+				$tempfile = tempnam(wfTempDir(), "imp");
+				$tempfp = fopen($tempfile, "wb");
+				if (is_numeric($part[content_length]))
+				{
+					$done = 0;
+					$buf = true;
+					while ($done < $part[content_length] && $buf)
+					{
+						$buf = fread($this->mHandle, min(self::BUF_SIZE, $part[content_length] - $done));
+						if ($tempfp)
+							fwrite($tempfp, $buf);
+						$done += strlen($buf);
+					}
+				}
+				else
+				{
+					$buf = true;
+					while ($buf)
+					{
+						$buf = fread($this->mHandle, self::BUF_SIZE);
+						if (($p = strpos($buf, "\n".$this->boundary)) !== false)
+						{
+							$pp = ftell($this->mHandle);
+							fseek($this->mHandle, $p+1-strlen($buf), 1);
+							fwrite($tempfp, substr($buf, 0, $p+1));
+							break;
+						}
+						else
+						{
+							/* Для ситуации, когда $this->boundary попадёт на границу буфера */
+							if (strlen($buf) == self::BUF_SIZE &&
+								($p = strrpos($buf, "\n")) !== false)
+							{
+								fseek($this->mHandle, $p+1-self::BUF_SIZE, 1);
+								$buf = substr($buf, 0, $p+1);
+							}
+							fwrite($tempfp, $buf);
+						}
+					}
+				}
+				fclose($tempfp);
+				/* Запоминаем часть */
+				$part['tempfile'] = $tempfile;
+				if ($part['content_id'])
+				{
+					$part['sha1'] = sha1_file($part['tempfile']);
+					$this->parts[$part['content_id']] = $part;
+				}
+				else
+					unlink($tempfile);
+			}
+			/* Открываем XML-часть */
+			if ($this->parts['Revisions'])
+			{
+				fclose($this->mHandle);
+				$this->mHandle = fopen($this->parts['Revisions']['tempfile'], 'rb');
+			}
+		}
+		/* Обычный XML-файл (не multipart) */
+		else
+			fseek($this->mHandle, $pos, 0);
 	}
 
+	/* Деструктор. Уничтожает временные файлы. */
+	function __destruct()
+	{
+		wfSuppressWarnings();
+		if ($this->mHandle)
+			fclose ($this->mHandle);
+		if ($this->parts)
+			foreach ($this->parts as $part)
+				unlink ($part['tempfile']);
+		wfRestoreWarnings();
+	}
+
 	function atEnd() {
 		return feof( $this->mHandle );
 	}
 
+	/* read next XML part chunk */
 	function readChunk() {
-		return fread( $this->mHandle, 32768 );
+		return fread( $this->mHandle, self::BUF_SIZE );
 	}
 
 	static function newFromFile( $filename ) {
-		$file = @fopen( $filename, 'rt' );
+		$file = @fopen( $filename, 'rb' );
 		if( !$file ) {
 			return new WikiErrorMsg( "importcantopen" );
 		}
Index: languages/messages/MessagesRu.php
===================================================================
--- languages/messages/MessagesRu.php	(revision 47934)
+++ languages/messages/MessagesRu.php	(working copy)
@@ -2088,6 +2088,8 @@
 'export-submit'     => 'Экспортировать',
 'export-addcattext' => 'Добавить страницы из категории:',
 'export-addcat'     => 'Добавить',
+'export-images'     => 'Экспортировать изображения',
+'export-selfcontained' => 'Включать содержимое изображений в экспортный файл',
 'export-download'   => 'Предложить сохранить как файл',
 'export-templates'  => 'Включить шаблоны',
 
@@ -2122,7 +2124,6 @@
 'import-interwiki-namespace' => 'Целевое пространство имён:',
 'importtext'                 => 'Пожалуйста, экспортируйте страницу из исходной вики, используя [[Special:Export|соответствующий инструмент]]. Сохраните файл на диск, а затем загрузите его сюда.',
 'importstart'                => 'Импортирование страниц…',
-'import-revision-count'      => '$1 {{PLURAL:$1|версия|версии|версий}}',
 'importnopages'              => 'Нет страниц для импортирования.',
 'importfailed'               => 'Не удалось импортировать: $1',
 'importunknownsource'        => 'Неизвестный тип импортируемой страницы',
@@ -2138,9 +2139,15 @@
 'importuploaderrortemp'      => 'Не удалось загрузить или импортировать файл. Временная папка отсутствует.',
 'import-parse-failure'       => 'Ошибка разбора XML при импорте',
 'import-noarticle'           => 'Нет страницы для импортирования!',
-'import-nonewrevisions'      => 'Все редакции были ранее импортированы.',
 'xml-error-string'           => '$1 в строке $2, позиции $3 (байт $4): $5',
 'import-upload'              => 'Загрузить XML-данные',
+'import-norevisions'         => 'Нет редакций для импортирования.',
+'import-nonewrevisions-localnewer' => 'Все редакции были ранее импортированы. Страница изменена локально.',
+'import-nonewrevisions'      => 'Все редакции были ранее импортированы. Локальных изменений нет.',
+'import-revision-count'      => '$1 {{PLURAL:$1|версия|версии|версий}}.',
+'import-revision-count-newpage' => '$1 {{PLURAL:$1|версия|версии|версий}} (новая страница).',
+'import-conflict'            => '$1 {{PLURAL:$1|версия|версии|версий}} (конфликт: $2).',
+'import-conflict-difflink'   => '$1 (импорт) и $2 (локальная)',
 'import-token-mismatch'      => 'Потеряны данные сеанса. Пожалуйста, попробуйте ещё раз.',
 'import-invalid-interwiki'   => 'Невозможно импортировать из указанной вики.',
 
Index: languages/messages/MessagesEn.php
===================================================================
--- languages/messages/MessagesEn.php	(revision 47934)
+++ languages/messages/MessagesEn.php	(working copy)
@@ -2529,6 +2529,8 @@
 'export-submit'     => 'Export',
 'export-addcattext' => 'Add pages from category:',
 'export-addcat'     => 'Add',
+'export-images'     => 'Export images',
+'export-selfcontained' => 'Include image contents into the export file',
 'export-download'   => 'Save as file',
 'export-templates'  => 'Include templates',
 
@@ -2564,7 +2566,6 @@
 'importtext'                 => 'Please export the file from the source wiki using the [[Special:Export|export utility]].
 Save it to your computer and upload it here.',
 'importstart'                => 'Importing pages...',
-'import-revision-count'      => '$1 {{PLURAL:$1|revision|revisions}}',
 'importnopages'              => 'No pages to import.',
 'importfailed'               => 'Import failed: <nowiki>$1</nowiki>',
 'importunknownsource'        => 'Unknown import source type',
@@ -2583,9 +2584,15 @@
 A temporary folder is missing.',
 'import-parse-failure'       => 'XML import parse failure',
 'import-noarticle'           => 'No page to import!',
-'import-nonewrevisions'      => 'All revisions were previously imported.',
 'xml-error-string'           => '$1 at line $2, col $3 (byte $4): $5',
 'import-upload'              => 'Upload XML data',
+'import-norevisions'         => 'No revisions to import.',
+'import-nonewrevisions-localnewer' => 'All revisions were previously imported. Page changed locally.',
+'import-nonewrevisions'      => 'All revisions were previously imported. No local changes.',
+'import-revision-count'      => '$1 {{PLURAL:$1|revision|revisions}}',
+'import-revision-count-newpage' => '$1 {{PLURAL:$1|revision|revisions}} (new page)',
+'import-conflict'            => '$1 {{PLURAL:$1|revision|revisions}} (conflict: $2)',
+'import-conflict-difflink'   => '$1 (imported) и $2 (local)',
 'import-token-mismatch'      => 'Loss of session data. Please try again.',
 'import-invalid-interwiki'   => 'Cannot import from the specified wiki.',
 
