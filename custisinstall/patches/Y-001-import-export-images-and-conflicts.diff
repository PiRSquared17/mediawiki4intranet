From: Vitaliy Filippov <vitali@st-filippov.office.custis.ru>
Subject: [PATCH] t/001-import-export-images-and-conflicts
Depends on: Y-000-translit-upload-filenames.diff

Totally improved MediaWiki Import and Export engine with conflict detection,
advanced export page list building options and support for exporting file data
over HTTP or inside the export file.

Requires running archive-image-renamer.php when applied to a non-empty MediaWiki
installation.

Signed-off-by: Vitaliy Filippov <vitali@st-filippov.office.custis.ru>

---
 includes/Export.php                 |   70 ++++++--
 includes/Import.php                 |  330 ++++++++++++++++++++++++++++-------
 includes/filerepo/LocalFile.php     |   74 ++++++++-
 includes/specials/SpecialExport.php |  117 +++++++------
 includes/specials/SpecialImport.php |   60 ++++++-
 languages/messages/MessagesEn.php   |   19 ++-
 languages/messages/MessagesRu.php   |   19 ++-
 7 files changed, 543 insertions(+), 146 deletions(-)

diff --git includes/Export.php includes/Export.php
index 5f040b1..f5d5e27 100644
--- includes/Export.php
+++ includes/Export.php
@@ -28,7 +28,8 @@ class WikiExporter {
 	var $list_authors = false ; # Return distinct author list (when not returning full history)
 	var $author_list = "" ;
 
-	var $dumpUploads = false;
+	var $dumpUploads = false;   # Dump uploaded files into the export file
+	var $selfContained = false; # Make export file self-contained (multipart/related)
 
 	const FULL = 0;
 	const CURRENT = 1;
@@ -77,6 +78,7 @@ class WikiExporter {
 	}
 
 	public function openStream() {
+		$this->writer->multipart = $this->dumpUploads && $this->selfContained;
 		$output = $this->writer->openStream();
 		$this->sink->writeOpenStream( $output );
 	}
@@ -84,6 +86,9 @@ class WikiExporter {
 	public function closeStream() {
 		$output = $this->writer->closeStream();
 		$this->sink->writeCloseStream( $output );
+		/* Dump $this->writer->binaries into multipart/related */
+		while ($part = $this->writer->nextPart())
+			$this->sink->writePart($part);
 	}
 
 	/**
@@ -293,7 +298,8 @@ class WikiExporter {
 				if( isset( $last ) ) {
 					$output = '';
 					if( $this->dumpUploads ) {
-						$output .= $this->writer->writeUploads( $last );
+						$output .= $this->writer->writeUploads( $last,
+							$this->history == WikiExporter::CURRENT ? 1 : null );
 					}
 					$output .= $this->writer->closePage();
 					$this->sink->writeClosePage( $output );
@@ -308,7 +314,8 @@ class WikiExporter {
 		if( isset( $last ) ) {
 			$output = '';
 			if( $this->dumpUploads ) {
-				$output .= $this->writer->writeUploads( $last );
+				$output .= $this->writer->writeUploads( $last,
+					$this->history == WikiExporter::CURRENT ? 1 : null );
 			}
 			$output .= $this->author_list;
 			$output .= $this->writer->closePage();
@@ -331,6 +338,10 @@ class WikiExporter {
  */
 class XmlDumpWriter {
 
+	var $boundary;
+	var $binaries;
+	var $multipart;
+
 	/**
 	 * Returns the export schema version.
 	 * @return string
@@ -352,7 +363,15 @@ class XmlDumpWriter {
 	function openStream() {
 		global $wgContLanguageCode;
 		$ver = $this->schemaVersion();
-		return Xml::element( 'mediawiki', array(
+		$mp = '';
+		if ($this->multipart)
+		{
+			$this->boundary = '--'.time();
+			$this->binaries = array();
+			$mp = "Content-Type: multipart/related; boundary=".$this->boundary."\n".$this->boundary."\nContent-Type: text/xml\nContent-ID: Revisions\n\n";
+		}
+		return $mp .
+			Xml::element( 'mediawiki', array(
 			'xmlns'              => "http://www.mediawiki.org/xml/export-$ver/",
 			'xmlns:xsi'          => "http://www.w3.org/2001/XMLSchema-instance",
 			'xsi:schemaLocation' => "http://www.mediawiki.org/xml/export-$ver/ " .
@@ -415,6 +434,22 @@ class XmlDumpWriter {
 		return "</mediawiki>\n";
 	}
 
+	function nextPart() {
+		if ($this->multipart && count($this->binaries) > 0)
+		{
+			list($name) = array_keys($this->binaries);
+			$data = $this->binaries[$name];
+			unset($this->binaries[$name]);
+			$data = @file_get_contents($data);
+			return $this->boundary.
+				"\nContent-Type: application/binary\n" .
+				"Content-Transfer-Encoding: Little-Endian\n" .
+				"Content-ID: $name\n" .
+				"Content-Length: ".strlen($data)."\n\n" .
+				$data;
+		}
+		return '';
+	}
 
 	/**
 	 * Opens a <page> section on the output stream, with data
@@ -482,7 +517,9 @@ class XmlDumpWriter {
 		} elseif( isset( $row->old_text ) ) {
 			// Raw text from the database may have invalid chars
 			$text = strval( Revision::getRevisionText( $row ) );
-			$out .= "      " . Xml::elementClean( 'text',
+			// Remove "export cuts"
+			$text = preg_replace( '/<!--\s*begindsp\s*\@?\s*-->.*?<!--\s*enddsp\s*\@?\s*-->/is', '', $text );
+			$out .= "      " . Xml::ElementClean( 'text',
 				array( 'xml:space' => 'preserve' ),
 				strval( $text ) ) . "\n";
 		} else {
@@ -566,12 +603,12 @@ class XmlDumpWriter {
 	/**
 	 * Warning! This data is potentially inconsistent. :(
 	 */
-	function writeUploads( $row ) {
+	function writeUploads( $row, $limit = null ) {
 		if( $row->page_namespace == NS_IMAGE ) {
 			$img = wfFindFile( $row->page_title );
 			if( $img ) {
 				$out = '';
-				foreach( array_reverse( $img->getHistory() ) as $ver ) {
+				foreach( $img->getHistory($limit) as $ver ) {
 					$out .= $this->writeUpload( $ver );
 				}
 				$out .= $this->writeUpload( $img );
@@ -582,13 +619,20 @@ class XmlDumpWriter {
 	}
 
 	function writeUpload( $file ) {
+		if ($this->multipart)
+		{
+			$partname = $file->isOld() ? $file->getArchiveName() : $file->getName();
+			$this->binaries[$partname] = $file->getPath();
+		}
 		return "    <upload>\n" .
 			$this->writeTimestamp( $file->getTimestamp() ) .
 			$this->writeContributor( $file->getUser( 'id' ), $file->getUser( 'text' ) ) .
-			"      " . Xml::elementClean( 'comment', null, $file->getDescription() ) . "\n" .
-			"      " . Xml::element( 'filename', null, $file->getName() ) . "\n" .
-			"      " . Xml::element( 'src', null, $file->getFullUrl() ) . "\n" .
-			"      " . Xml::element( 'size', null, $file->getSize() ) . "\n" .
+			"      " . Xml::ElementClean( 'comment', null, $file->getDescription() ) . "\n" .
+			"      " . Xml::Element( 'filename', null, $file->getName() ) . "\n" .
+			"      " . Xml::Element( 'src',
+			                      array('sha1' => $file->getSha1()),
+			                      $partname ? "multipart://$partname" : $file->getFullUrl() ) . "\n" .
+			"      " . Xml::Element( 'size', null, $file->getSize() ) . "\n" .
 			"    </upload>\n";
 	}
 
@@ -624,6 +668,10 @@ class DumpOutput {
 		$this->write( $string );
 	}
 
+	function writePart( $string ) {
+		$this->write( $string );
+	}
+
 	/**
 	 * Override to write to a different stream type.
 	 * @return bool
diff --git includes/Import.php includes/Import.php
index 56e7a7f..c4f4ef9 100644
--- includes/Import.php
+++ includes/Import.php
@@ -87,6 +87,10 @@ class WikiRevision {
 		$this->filename = $filename;
 	}
 
+	function setSha1( $sha1 ) {
+		$this->sha1 = trim( $sha1 );
+	}
+
 	function setSize( $size ) {
 		$this->size = intval( $size );
 	}
@@ -139,6 +143,10 @@ class WikiRevision {
 		return $this->filename;
 	}
 
+	function getSha1() {
+		return $this->sha1;
+	}
+
 	function getSize() {
 		return $this->size;
 	}
@@ -181,7 +189,7 @@ class WikiRevision {
 		} else {
 			$created = false;
 
-			$prior = $dbw->selectField( 'revision', '1',
+			$prior = $dbw->selectField( 'revision', 'rev_id',
 				array( 'rev_page' => $pageId,
 					'rev_timestamp' => $dbw->timestamp( $this->timestamp ),
 					'rev_user_text' => $userText,
@@ -189,10 +197,11 @@ class WikiRevision {
 				__METHOD__
 			);
 			if( $prior ) {
+				$prior = Revision::newFromId( $prior );
 				// FIXME: this could fail slightly for multiple matches :P
 				wfDebug( __METHOD__ . ": skipping existing revision for [[" .
 					$this->title->getPrefixedText() . "]], timestamp " . $this->timestamp . "\n" );
-				return false;
+				return $prior;
 			}
 		}
 
@@ -235,7 +244,9 @@ class WikiRevision {
 		}
 		$GLOBALS['wgTitle'] = $tempTitle;
 
-		return true;
+		# A hack. TOdo it better?
+		$revision->_imported = true;
+		return $revision;
 	}
 	
 	function importLogItem() {
@@ -281,29 +292,10 @@ class WikiRevision {
 		$dbw->insert( 'logging', $data, __METHOD__ );
 	}
 
-	function importUpload() {
+	function importUpload()
+	{
 		wfDebug( __METHOD__ . ": STUB\n" );
 
-		/**
-			// from file revert...
-			$source = $this->file->getArchiveVirtualUrl( $this->oldimage );
-			$comment = $wgRequest->getText( 'wpComment' );
-			// TODO: Preserve file properties from database instead of reloading from file
-			$status = $this->file->upload( $source, $comment, $comment );
-			if( $status->isGood() ) {
-		*/
-
-		/**
-			// from file upload...
-		$this->mLocalFile = wfLocalFile( $nt );
-		$this->mDestName = $this->mLocalFile->getName();
-		//....
-			$status = $this->mLocalFile->upload( $this->mTempPath, $this->mComment, $pageText,
-			File::DELETE_SOURCE, $this->mFileProps );
-			if ( !$status->isGood() ) {
-				$resultDetails = array( 'internal' => $status->getWikiText() );
-		*/
-
 		// @fixme upload() uses $wgUser, which is wrong here
 		// it may also create a page without our desire, also wrong potentially.
 		// and, it will record a *current* upload, but we might want an archive version here
@@ -315,26 +307,67 @@ class WikiRevision {
 			return false;
 		}
 
+		/* First check if file already exists */
+		if ($file->exists())
+		{
+			/* Backward-compatibility: support export files without sha1 */
+			if ($this->getSha1() && $file->getSha1() == $this->getSha1() ||
+				!$this->getSha1() && $file->getTimestamp() == $this->getTimestamp())
+			{
+				wfDebug( "IMPORT: File already exists and is equal to imported (".$this->getTimestamp().").\n" );
+				return false;
+			}
+			$history = $file->getHistory(null, $this->getTimestamp(), $this->getTimestamp());
+			foreach ($history as $oldfile)
+			{
+				if (!$this->getSha1() || $oldfile->getSha1() == $this->getSha1())
+				{
+					wfDebug( "IMPORT: File revision already exists at its timestamp (".$this->getTimestamp().") and is equal to imported.\n" );
+					return false;
+				}
+			}
+		}
+
+		/* Get file source into a temporary file */
 		$source = $this->downloadSource();
 		if( !$source ) {
 			wfDebug( "IMPORT: Could not fetch remote file. :(\n" );
 			return false;
 		}
 
-		$status = $file->upload( $source,
-			$this->getComment(),
-			$this->getComment(), // Initial page, if none present...
-			File::DELETE_SOURCE,
-			false, // props...
-			$this->getTimestamp() );
+		// @fixme upload() uses $wgUser, which is wrong here
+		// it may also create a page without our desire, also wrong potentially.
+
+		if ($file->exists() && $file->getTimestamp() > $this->getTimestamp())
+		{
+			/* Upload an *archive* version */
+			wfDebug( "Importing an archive $arch version of file (".$this->getTimestamp().")\n" );
+			$status = $file->uploadIntoArchive( $source,
+				$this->getComment(),
+				$this->getComment(), // Initial page, if none present...
+				File::DELETE_SOURCE,
+				false, // props...
+				$this->getTimestamp() );
+		}
+		else
+		{
+			wfDebug( "Importing a new current version of file (".$this->getTimestamp().")\n" );
+			/* Upload a *current* version */
+			$status = $file->upload( $source,
+				$this->getComment(),
+				$this->getComment(), // Initial page, if none present...
+				File::DELETE_SOURCE,
+				false, // props...
+				$this->getTimestamp() );
+		}
 
 		if( $status->isGood() ) {
 			// yay?
-			wfDebug( "IMPORT: is ok?\n" );
+			wfDebug( "IMPORT: file imported OK\n" );
 			return true;
 		}
 
-		wfDebug( "IMPORT: is bad? " . $status->getXml() . "\n" );
+		wfDebug( "IMPORT: file import FAILED: " . $status->getXml() . "\n" );
 		return false;
 
 	}
@@ -345,6 +378,12 @@ class WikiRevision {
 			return false;
 		}
 
+		/* Если файл прикреплён как multipart-часть, вернём его */
+		$src = $this->getSrc();
+		if (is_file( $src ))
+			return $src;
+
+		/* Иначе нужно заморочиться и скачать... */
 		$tempo = tempnam( wfTempDir(), 'download' );
 		$f = fopen( $tempo, 'wb' );
 		if( !$f ) {
@@ -353,7 +392,6 @@ class WikiRevision {
 		}
 
 		// @fixme!
-		$src = $this->getSrc();
 		$data = Http::get( $src );
 		if( !$data ) {
 			wfDebug( "IMPORT: couldn't fetch source $src\n" );
@@ -390,6 +428,7 @@ class WikiImporter {
 	function __construct( $source ) {
 		$this->setRevisionCallback( array( $this, "importRevision" ) );
 		$this->setUploadCallback( array( $this, "importUpload" ) );
+		$this->setPageCallback( array( $this, "beginPage" ) );
 		$this->setLogItemCallback( array( $this, "importLogItem" ) );
 		$this->mSource = $source;
 	}
@@ -408,11 +447,11 @@ class WikiImporter {
 
 	function stripXmlNamespace($name) {
 		if( $this->mXmlNamespace ) {
-	               return(preg_replace($this->mXmlNamespace,'',$name,1));
+			return(preg_replace($this->mXmlNamespace,'',$name,1));
 		}
 		else {
-		       return($name);
-                }
+			return($name);
+		}
 	}
    
 	# --------------
@@ -563,12 +602,13 @@ class WikiImporter {
 	}
 
 	/**
-	 * Dummy for now...
+	 * Per-revision file import callback, performs the upload.
+	 * @param $revision WikiRevision
+	 * @private
 	 */
 	function importUpload( $revision ) {
-		//$dbw = wfGetDB( DB_MASTER );
-		//return $dbw->deadlockLoop( array( $revision, 'importUpload' ) );
-		return false;
+		$dbw = wfGetDB( DB_MASTER );
+		return $dbw->deadlockLoop( array( $revision, 'importUpload' ) );
 	}
 
 	/**
@@ -606,12 +646,15 @@ class WikiImporter {
 	 * @param $origTitle Title
 	 * @param $revisionCount int
 	 * @param $successCount Int: number of revisions for which callback returned true
+	 * @param $lastExistingRevision Revision
+	 * @param $lastLocalRevision Revision
+	 * @param $lastRevision Revision
 	 * @private
 	 */
-	function pageOutCallback( $title, $origTitle, $revisionCount, $successCount ) {
+	function pageOutCallback() {
 		if( is_callable( $this->mPageOutCallback ) ) {
-			call_user_func( $this->mPageOutCallback, $title, $origTitle,
-				$revisionCount, $successCount );
+			$args = func_get_args();
+			call_user_func_array( $this->mPageOutCallback, $args );
 		}
 	}
 
@@ -621,7 +664,7 @@ class WikiImporter {
 	}
 
 	function in_start( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_start $name" );
 		if( $name != "mediawiki" ) {
 			return $this->throwXMLerror( "Expected <mediawiki>, got <$name>" );
@@ -630,7 +673,7 @@ class WikiImporter {
 	}
 
 	function in_mediawiki( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_mediawiki $name" );
 		if( $name == 'siteinfo' ) {
 			xml_set_element_handler( $parser, "in_siteinfo", "out_siteinfo" );
@@ -640,6 +683,9 @@ class WikiImporter {
 			$this->workSuccessCount = 0;
 			$this->uploadCount = 0;
 			$this->uploadSuccessCount = 0;
+			$this->lastRevision = NULL;
+			$this->lastLocalRevision = NULL;
+			$this->lastExistingRevision = NULL;
 			xml_set_element_handler( $parser, "in_page", "out_page" );
 		} elseif( $name == 'logitem' ) {
 			$this->push( $name );
@@ -650,7 +696,7 @@ class WikiImporter {
 		}
 	}
 	function out_mediawiki( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_mediawiki $name" );
 		if( $name != "mediawiki" ) {
 			return $this->throwXMLerror( "Expected </mediawiki>, got </$name>" );
@@ -661,7 +707,7 @@ class WikiImporter {
 
 	function in_siteinfo( $parser, $name, $attribs ) {
 		// no-ops for now
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_siteinfo $name" );
 		switch( $name ) {
 		case "sitename":
@@ -677,15 +723,37 @@ class WikiImporter {
 	}
 
 	function out_siteinfo( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		if( $name == "siteinfo" ) {
 			xml_set_element_handler( $parser, "in_mediawiki", "out_mediawiki" );
 		}
 	}
 
+	function beginPage( $title )
+	{
+		$fields = Revision::selectFields();
+		$fields[] = 'page_namespace';
+		$fields[] = 'page_title';
+		$fields[] = 'page_latest';
+		$dbr = wfGetDB( DB_MASTER );
+		$res = $dbr->select(
+			array( 'page', 'revision' ),
+			$fields,
+			array( 'page_id=rev_page',
+			       'page_namespace' => $this->pageTitle->getNamespace(),
+			       'page_title'     => $this->pageTitle->getDBkey(),
+			       'rev_len IS NOT NULL' ),
+			'Revision::fetchRow',
+			array( 'LIMIT' => 1,
+			       'ORDER BY' => 'rev_timestamp DESC' ) );
+		$row = $res->fetchObject();
+		$res->free();
+		if ($row)
+			$this->lastLocalRevision = new Revision( $row );
+	}
 
 	function in_page( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_page $name" );
 		switch( $name ) {
 		case "id":
@@ -726,7 +794,7 @@ class WikiImporter {
 	}
 
 	function out_page( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_page $name" );
 		$this->pop();
 		if( $name != "page" ) {
@@ -735,7 +803,9 @@ class WikiImporter {
 		xml_set_element_handler( $parser, "in_mediawiki", "out_mediawiki" );
 
 		$this->pageOutCallback( $this->pageTitle, $this->origTitle,
-			$this->workRevisionCount, $this->workSuccessCount );
+			$this->workRevisionCount, $this->workSuccessCount,
+			$this->lastExistingRevision, $this->lastLocalRevision,
+			$this->lastRevision );
 
 		$this->workTitle = null;
 		$this->workRevision = null;
@@ -746,7 +816,7 @@ class WikiImporter {
 	}
 
 	function in_nothing( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_nothing $name" );
 		return $this->throwXMLerror( "No child elements allowed here; got <$name>" );
 	}
@@ -757,7 +827,7 @@ class WikiImporter {
 	}
 
 	function out_append( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_append $name" );
 		if( $name != $this->appendfield ) {
 			return $this->throwXMLerror( "Expected </{$this->appendfield}>, got </$name>" );
@@ -835,7 +905,15 @@ class WikiImporter {
 			break;
 		case "src":
 			if( $this->workRevision )
+			{
+				/* Передаём путь к файлу, если он уже загружен */
+				if (substr($this->appenddata, 0, 12) == 'multipart://' &&
+				    ($p = $this->mSource->parts[substr($this->appenddata, 12)]))
+					$this->workRevision->setSrc($p['tempfile']);
+				/* Иначе передаём URL */
+				else
 				$this->workRevision->setSrc( $this->appenddata );
+			}
 			break;
 		case "size":
 			if( $this->workRevision )
@@ -853,7 +931,7 @@ class WikiImporter {
 	}
 
 	function in_revision( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_revision $name" );
 		switch( $name ) {
 		case "id":
@@ -875,7 +953,7 @@ class WikiImporter {
 	}
 
 	function out_revision( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_revision $name" );
 		$this->pop();
 		if( $name != "revision" ) {
@@ -886,14 +964,17 @@ class WikiImporter {
 		if( $this->workRevision ) {
 			$ok = call_user_func_array( $this->mRevisionCallback,
 				array( $this->workRevision, $this ) );
-			if( $ok ) {
+			if( is_object($ok) && $ok->_imported ) {
+				$this->lastRevision = $ok;
 				$this->workSuccessCount++;
-			}
+			} else if ( is_object($ok) && ( !$this->lastExistingRevision ||
+				$ok->getTimestamp() > $this->lastExistingRevision->getTimestamp() ) )
+				$this->lastExistingRevision = $ok;
 		}
 	}
 	
 	function in_logitem( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_logitem $name" );
 		switch( $name ) {
 		case "id":
@@ -917,7 +998,7 @@ class WikiImporter {
 	}
 
 	function out_logitem( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_logitem $name" );
 		$this->pop();
 		if( $name != "logitem" ) {
@@ -935,7 +1016,7 @@ class WikiImporter {
 	}
 
 	function in_upload( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_upload $name" );
 		switch( $name ) {
 		case "timestamp":
@@ -943,6 +1024,8 @@ class WikiImporter {
 		case "text":
 		case "filename":
 		case "src":
+			if ($this->workRevision && $attribs['sha1'])
+				$this->workRevision->setSha1( $attribs['sha1'] );
 		case "size":
 			$this->appendfield = $name;
 			xml_set_element_handler( $parser, "in_nothing", "out_append" );
@@ -958,7 +1041,7 @@ class WikiImporter {
 	}
 
 	function out_upload( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_revision $name" );
 		$this->pop();
 		if( $name != "upload" ) {
@@ -976,7 +1059,7 @@ class WikiImporter {
 	}
 
 	function in_contributor( $parser, $name, $attribs ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "in_contributor $name" );
 		switch( $name ) {
 		case "username":
@@ -992,7 +1075,7 @@ class WikiImporter {
 	}
 
 	function out_contributor( $parser, $name ) {
-	        $name = $this->stripXmlNamespace($name);
+		$name = $this->stripXmlNamespace($name);
 		$this->debug( "out_contributor $name" );
 		$this->pop();
 		if( $name != "contributor" ) {
@@ -1043,6 +1126,10 @@ class ImportStringSource {
 			return $this->mString;
 		}
 	}
+
+	function nextPart() {
+		return false;
+	}
 }
 
 /**
@@ -1050,20 +1137,131 @@ class ImportStringSource {
  * @ingroup SpecialPage
  */
 class ImportStreamSource {
-	function __construct( $handle ) {
+
+	var $buf;
+	var $eop;
+	var $boundary;
+
+	const BUF_SIZE = 65536;
+
+	function __construct( $handle )
+	{
 		$this->mHandle = $handle;
+		$this->eop = false;
+		$this->buf = '';
+		$this->boundary = '';
+		$pos = ftell($this->mHandle);
+		$s = fgets($this->mHandle);
+		/* multipart-файл? */
+		if (preg_match("/Content-Type:\s*multipart\/related; boundary=([^\r\n]+)\r*\n/s", $s, $m))
+		{
+			$this->boundary = $m[1];
+			$this->parts = array();
+			/* Распаковываем файл на части.
+			 * Смысл в том, что процедура импорта загруженных файлов
+			 * должна видеть части. Но они идут после XML-файла в multipart
+			 * документе. Точнее, в принципе, в произвольном месте.
+			 */
+			while (!feof($this->mHandle))
+			{
+				$s = trim(fgets($this->mHandle));
+				if ($s != $this->boundary)
+					break;
+				$part = array();
+				/* Читаем заголовки */
+				while ($s != "\n" && $s != "\r\n")
+				{
+					$s = fgets($this->mHandle);
+					if (preg_match('/([a-z0-9\-\_]+):\s*(.*?)\s*$/is', $s, $m))
+						$part[str_replace('-','_',strtolower($m[1]))] = $m[2];
+				}
+				/* Читаем данные */
+				$tempfile = tempnam(wfTempDir(), "imp");
+				$tempfp = fopen($tempfile, "wb");
+				if (is_numeric($part[content_length]))
+				{
+					$done = 0;
+					$buf = true;
+					while ($done < $part[content_length] && $buf)
+					{
+						$buf = fread($this->mHandle, min(self::BUF_SIZE, $part[content_length] - $done));
+						if ($tempfp)
+							fwrite($tempfp, $buf);
+						$done += strlen($buf);
+					}
+				}
+				else
+				{
+					$buf = true;
+					while ($buf)
+					{
+						$buf = fread($this->mHandle, self::BUF_SIZE);
+						if (($p = strpos($buf, "\n".$this->boundary)) !== false)
+						{
+							$pp = ftell($this->mHandle);
+							fseek($this->mHandle, $p+1-strlen($buf), 1);
+							fwrite($tempfp, substr($buf, 0, $p+1));
+							break;
+						}
+						else
+						{
+							/* Для ситуации, когда $this->boundary попадёт на границу буфера */
+							if (strlen($buf) == self::BUF_SIZE &&
+								($p = strrpos($buf, "\n")) !== false)
+							{
+								fseek($this->mHandle, $p+1-self::BUF_SIZE, 1);
+								$buf = substr($buf, 0, $p+1);
+							}
+							fwrite($tempfp, $buf);
+						}
+					}
+				}
+				fclose($tempfp);
+				/* Запоминаем часть */
+				$part['tempfile'] = $tempfile;
+				if ($part['content_id'])
+				{
+					$part['sha1'] = sha1_file($part['tempfile']);
+					$this->parts[$part['content_id']] = $part;
+				}
+				else
+					unlink($tempfile);
+			}
+			/* Открываем XML-часть */
+			if ($this->parts['Revisions'])
+			{
+				fclose($this->mHandle);
+				$this->mHandle = fopen($this->parts['Revisions']['tempfile'], 'rb');
+			}
+		}
+		/* Обычный XML-файл (не multipart) */
+		else
+			fseek($this->mHandle, $pos, 0);
+	}
+
+	/* Деструктор. Уничтожает временные файлы. */
+	function __destruct()
+	{
+		wfSuppressWarnings();
+		if ($this->mHandle)
+			fclose ($this->mHandle);
+		if ($this->parts)
+			foreach ($this->parts as $part)
+				unlink ($part['tempfile']);
+		wfRestoreWarnings();
 	}
 
 	function atEnd() {
 		return feof( $this->mHandle );
 	}
 
+	/* read next XML part chunk */
 	function readChunk() {
-		return fread( $this->mHandle, 32768 );
+		return fread( $this->mHandle, self::BUF_SIZE );
 	}
 
 	static function newFromFile( $filename ) {
-		$file = @fopen( $filename, 'rt' );
+		$file = @fopen( $filename, 'rb' );
 		if( !$file ) {
 			return new WikiErrorMsg( "importcantopen" );
 		}
diff --git includes/filerepo/LocalFile.php includes/filerepo/LocalFile.php
index d8debb5..27aeca2 100644
--- includes/filerepo/LocalFile.php
+++ includes/filerepo/LocalFile.php
@@ -776,6 +776,66 @@ class LocalFile extends File
 	}
 
 	/**
+	 * Upload a file directly into archive. Generally for Special:Import
+	 */
+	function uploadIntoArchive( $srcPath, $comment, $pageText, $flags = 0, $props = false, $timestamp = false )
+	{
+		$this->lock();
+		$dstName = gmdate( 'YmdHis', wfTimestamp( TS_UNIX, $timestamp ) ) . '!' . $this->getPhys();
+		$status = $this->publish( $srcPath, $flags, $dstName );
+		if ( $status->ok ) {
+			if ( !$this->recordOldUpload( $dstName, $comment, $pageText, $props, $timestamp ) ) {
+				$status->fatal( 'filenotfound', $srcPath );
+			}
+		}
+		$this->unlock();
+		return $status;
+	}
+
+	/**
+	 * Record a file upload in the upload log and the oldimage table
+	 */
+	function recordOldUpload( $dstName, $comment, $pageText, $props = false, $timestamp = false )
+	{
+		global $wgUser;
+
+		$dbw = $this->repo->getMasterDB();
+
+		$dstPath = $this->repo->getZonePath('public') . '/archive/' . $this->getHashPath() . $dstName;
+		$props = self::getPropsFromPath( $dstPath );
+		if (!$props['fileExists'])
+			return false;
+
+		$props['timestamp'] = wfTimestamp( TS_MW, $timestamp );
+		list($props['major_mime'], $props['minor_mime']) =
+			self::splitMime( "{$props['major_mime']}/{$props['minor_mime']}" );
+
+		$dbw->insert( 'oldimage',
+			array(
+				'oi_name'         => $this->getName(),
+				'oi_archive_name' => $dstName,
+				'oi_size'         => $props['size'],
+				'oi_width'        => intval($props['width']),
+				'oi_height'       => intval($props['height']),
+				'oi_bits'         => $props['bits'],
+				'oi_timestamp'    => $props['timestamp'],
+				'oi_description'  => $comment,
+				'oi_user'         => $wgUser->getId(),
+				'oi_user_text'    => $wgUser->getName(),
+				'oi_metadata'     => $props['metadata'],
+				'oi_media_type'   => $props['media_type'],
+				'oi_major_mime'   => $props['major_mime'],
+				'oi_minor_mime'   => $props['minor_mime'],
+				'oi_sha1'         => $props['sha1'],
+			), __METHOD__
+		);
+
+		$dbw->immediateCommit();
+
+		return true;
+	}
+
+	/**
 	 * Record a file upload in the upload log and the image table
 	 */
 	function recordUpload2( $oldver, $comment, $pageText, $props = false, $timestamp = false, $user = null )
@@ -948,15 +1008,21 @@ class LocalFile extends File
 	 *
 	 * @param string $sourcePath Local filesystem path to the source image
 	 * @param integer $flags A bitwise combination of:
-	 *     File::DELETE_SOURCE    Delete the source file, i.e. move
-	 *         rather than copy
+	 *     File::DELETE_SOURCE       Delete the source file, i.e. move rather than copy
+	 * @param string $dstName Local wanted path (for example some archive
+	 *        path to publish image into the archive directly)
 	 * @return FileRepoStatus object. On success, the value member contains the
 	 *     archive name, or an empty string if it was a new file.
 	 */
-	function publish( $srcPath, $flags = 0 ) {
+	function publish( $srcPath, $flags = 0, $dstName = NULL ) {
 		$this->lock();
+		if (!$dstName)
 		$dstRel = $this->getRel();
-		$archiveName = gmdate( 'YmdHis' ) . '!'. $this->getPhys();
+		else
+			$dstRel = 'archive/' . $this->getHashPath() . $dstName;
+		# Изначальное gmdate( 'YmdHis' ) - это НИФИГА не правильно!
+		# Получается, что в имени файла один timestamp, а в базе другой...
+		$archiveName = gmdate( 'YmdHis', wfTimestamp( TS_UNIX, $this->getTimestamp() ) ) . '!'. $this->getPhys();
 		$archiveRel = 'archive/' . $this->getHashPath() . $archiveName;
 		$flags = $flags & File::DELETE_SOURCE ? LocalRepo::DELETE_SOURCE : 0;
 		$status = $this->repo->publish( $srcPath, $dstRel, $archiveRel, $flags );
diff --git includes/specials/SpecialExport.php includes/specials/SpecialExport.php
index 898b5a7..1b68ec9 100644
--- includes/specials/SpecialExport.php
+++ includes/specials/SpecialExport.php
@@ -21,28 +21,36 @@
  * @ingroup SpecialPage
  */
 
-function wfExportGetPagesFromCategory( $title ) {
+function wfExportGetPagesFromCategory(&$catname, &$modifydate, &$namespace) {
 	global $wgContLang;
 
-	$name = $title->getDBkey();
-
 	$dbr = wfGetDB( DB_SLAVE );
+	$from = array('page');
+	$where = array();
+
+	if (strlen($catname) && ($catname = Title::makeTitleSafe(NS_MAIN, $catname)))
+	{
+		$from[] = 'categorylinks';
+		$where[] = 'cl_from=page_id';
+		$where['cl_to'] = $catname = $catname->getDbKey();
+	}
 
-	list( $page, $categorylinks ) = $dbr->tableNamesN( 'page', 'categorylinks' );
-	$sql = "SELECT page_namespace, page_title FROM $page " .
-		"JOIN $categorylinks ON cl_from = page_id " .
-		"WHERE cl_to = " . $dbr->addQuotes( $name );
+	if (strlen($modifydate) && ($modifydate = wfTimestampOrNull(TS_MW, $modifydate)))
+	{
+		$where[] = "page_touched>$modifydate";
+		$modifydate = wfTimestamp(TS_UNIX, $modifydate);
+	}
 
-	$pages = array();
-	$res = $dbr->query( $sql, 'wfExportGetPagesFromCategory' );
-	while ( $row = $dbr->fetchObject( $res ) ) {
-		$n = $row->page_title;
-		if ($row->page_namespace) {
-			$ns = $wgContLang->getNsText( $row->page_namespace );
-			$n = $ns . ':' . $n;
-		}
+	if (strlen($namespace) && ($namespace = Title::newFromText("$namespace:A", NS_MAIN)))
+		$where['page_namespace'] = $namespace = $namespace->getNamespace();
 
-		$pages[] = $n;
+	$pages = array();
+	$res = $dbr->select($from, array('page_namespace', 'page_title'), $where, __METHOD__);
+	while ($row = $dbr->fetchRow($res))
+	{
+		$row = Title::makeTitleSafe($row['page_namespace'], $row['page_title']);
+		if ($row)
+			$pages[] = $row->getPrefixedText();
 	}
 	$dbr->freeResult($res);
 
@@ -105,13 +113,6 @@ function wfExportGetLinks( $inputPages, $pageSet, $table, $fields, $join ) {
 }
 
 /**
- * Callback function to remove empty strings from the pages array.
- */
-function wfFilterPage( $page ) {
-	return $page !== '' && $page !== null;
-}
-
-/**
  *
  */
 function wfSpecialExport( $page = '' ) {
@@ -120,23 +121,25 @@ function wfSpecialExport( $page = '' ) {
 
 	$curonly = true;
 	$doexport = false;
-
-	if ( $wgRequest->getCheck( 'addcat' ) ) {
-		$page = $wgRequest->getText( 'pages' );
-		$catname = $wgRequest->getText( 'catname' );
-
-		if ( $catname !== '' && $catname !== NULL && $catname !== false ) {
-			$t = Title::makeTitleSafe( NS_MAIN, $catname );
-			if ( $t ) {
-				/**
-				 * @fixme This can lead to hitting memory limit for very large
-				 * categories. Ideally we would do the lookup synchronously
-				 * during the export in a single query.
-				 */
-				$catpages = wfExportGetPagesFromCategory( $t );
-				if ( $catpages ) $page .= "\n" . implode( "\n", $catpages );
-			}
-		}
+	$errors = array();
+
+	if ($wgRequest->getCheck('addcat'))
+	{
+		$page = $wgRequest->getText('pages');
+		$catname = $wgRequest->getText('catname');
+		$modifydate = $wgRequest->getText('modifydate');
+		$namespace = $wgRequest->getText('namespace');
+		$catpages = wfExportGetPagesFromCategory($catname, $modifydate, $namespace);
+		if ($catpages)
+			$page .= "\n" . implode("\n", $catpages);
+		if (!$catname && strlen($catname = $wgRequest->getText('catname')))
+			$errors[] = array('export-invalid-catname', $catname);
+		if ($modifydate)
+			$modifydate = wfTimestamp(TS_DB, $modifydate);
+		else if ($modifydate = $wgRequest->getText('modifydate'))
+			$errors[] = array('export-invalid-modifydate', $modifydate);
+		if (!$namespace && strlen($namespace = $wgRequest->getText('namespace')))
+			$errors[] = array('export-invalid-namespace', $namespace);
 	}
 	else if( $wgRequest->wasPosted() && $page == '' ) {
 		$page = $wgRequest->getText( 'pages' );
@@ -205,19 +208,20 @@ function wfSpecialExport( $page = '' ) {
 		}
 
 		/* Split up the input and look up linked pages */
-		$inputPages = array_filter( explode( "\n", $page ), 'wfFilterPage' );
+		$inputPages = array();
+		foreach (explode("\n", $page) as $p)
+			if ($p !== '' && $p !== null)
+				$inputPages[] = Title::newFromText($p)->getPrefixedText();
 		$pageSet = array_flip( $inputPages );
 
 		if( $wgRequest->getCheck( 'templates' ) ) {
 			$pageSet = wfExportGetTemplates( $inputPages, $pageSet );
 		}
 
-		/*
 		// Enable this when we can do something useful exporting/importing image information. :)
 		if( $wgRequest->getCheck( 'images' ) ) {
 			$pageSet = wfExportGetImages( $inputPages, $pageSet );
 		}
-		*/
 
 		$pages = array_keys( $pageSet );
 
@@ -241,6 +245,8 @@ function wfSpecialExport( $page = '' ) {
 
 		$exporter = new WikiExporter( $db, $history, $buffer );
 		$exporter->list_authors = $list_authors ;
+		$exporter->dumpUploads = $wgRequest->getCheck('images') ? true : false;
+		$exporter->selfContained = $wgRequest->getCheck('selfcontained') ? true : false;
 		$exporter->openStream();
 
 		foreach( $pages as $page ) {
@@ -278,22 +284,31 @@ function wfSpecialExport( $page = '' ) {
 	$form = Xml::openElement( 'form', array( 'method' => 'post',
 		'action' => $self->getLocalUrl( 'action=submit' ) ) );
 
-	$form .= Xml::inputLabel( wfMsg( 'export-addcattext' )	, 'catname', 'catname', 40 ) . '&nbsp;';
-	$form .= Xml::submitButton( wfMsg( 'export-addcat' ), array( 'name' => 'addcat' ) ) . '<br />';
+	foreach ($errors as $e)
+		$form .= wfMsgExt($e[0], array('parse'), $e[1]);
+
+	$form .= wfMsgExt( 'export-addpages', 'parse' );
+	$form .= '<p>';
+	$form .= Xml::inputLabel( wfMsg( 'export-catname' ), 'catname', 'catname', 40, $catname ) . '&nbsp; ';
+	$form .= Xml::inputLabel( wfMsg( 'export-namespace' ), 'namespace', 'namespace', 20, $namespace ) . '&nbsp; ';
+	$form .= Xml::inputLabel( wfMsg( 'export-modifydate' ), 'modifydate', 'modifydate', 20, $modifydate ) . '&nbsp; ';
+	$form .= Xml::submitButton( wfMsg( 'export-addcat' ), array( 'name' => 'addcat' ) );
+	$form .= '</p>';
 
 	$form .= Xml::openElement( 'textarea', array( 'name' => 'pages', 'cols' => 40, 'rows' => 10 ) );
 	$form .= htmlspecialchars( $page );
 	$form .= Xml::closeElement( 'textarea' );
 	$form .= '<br />';
 
-	if( $wgExportAllowHistory ) {
-		$form .= Xml::checkLabel( wfMsg( 'exportcuronly' ), 'curonly', 'curonly', true ) . '<br />';
-	} else {
+	if( $wgExportAllowHistory )
+		$form .= Xml::checkLabel( wfMsg( 'exportcuronly' ), 'curonly', 'curonly', $wgRequest->getCheck('curonly') ? true : false ) . '<br />';
+	else
 		$wgOut->addHTML( wfMsgExt( 'exportnohistory', 'parse' ) );
-	}
-	$form .= Xml::checkLabel( wfMsg( 'export-templates' ), 'templates', 'wpExportTemplates', false ) . '<br />';
+
+	$form .= Xml::checkLabel( wfMsg( 'export-templates' ), 'templates', 'wpExportTemplates', $wgRequest->getCheck('templates') ? true : false ) . '<br />';
 	// Enable this when we can do something useful exporting/importing image information. :)
-	//$form .= Xml::checkLabel( wfMsg( 'export-images' ), 'images', 'wpExportImages', false ) . '<br />';
+	$form .= Xml::checkLabel( wfMsg( 'export-images' ), 'images', 'wpExportImages', $wgRequest->getCheck('images') ? true : false ) . '<br />';
+	$form .= Xml::checkLabel( wfMsg( 'export-selfcontained' ), 'selfcontained', 'wpSelfContained', $wgRequest->getCheck('selfcontained') ? true : false ) . '<br />';
 	$form .= Xml::checkLabel( wfMsg( 'export-download' ), 'wpDownload', 'wpDownload', true ) . '<br />';
 
 	$form .= Xml::submitButton( wfMsg( 'export-submit' ), array( 'accesskey' => 's' ) );
diff --git includes/specials/SpecialImport.php includes/specials/SpecialImport.php
index 5e1a653..e24c6b2 100644
--- includes/specials/SpecialImport.php
+++ includes/specials/SpecialImport.php
@@ -264,7 +264,9 @@ class ImportReporter {
 		$wgOut->addHTML( "<ul>\n" );
 	}
 
-	function reportPage( $title, $origTitle, $revisionCount, $successCount ) {
+	function reportPage( $title, $origTitle, $revisionCount, $successCount,
+		$lastExistingRevision, $lastLocalRevision, $lastRevision )
+	{
 		global $wgOut, $wgUser, $wgLang, $wgContLang;
 
 		$skin = $wgUser->getSkin();
@@ -274,12 +276,56 @@ class ImportReporter {
 		$localCount = $wgLang->formatNum( $successCount );
 		$contentCount = $wgContLang->formatNum( $successCount );
 
-		if( $successCount > 0 ) {
-			$wgOut->addHTML( "<li>" . $skin->makeKnownLinkObj( $title ) . " " .
-				wfMsgExt( 'import-revision-count', array( 'parsemag', 'escape' ), $localCount ) .
-				"</li>\n"
-			);
+		/* No revisions in import */
+		if (!$lastExistingRevision && $successCount == 0)
+			$msg = wfMsgHtml('import-norevisions');
+
+		/* New page imported */
+		else if (!$lastLocalRevision && $successCount > 0)
+			$msg = wfMsgExt('import-revision-count-newpage', array('parsemag', 'escape'), $localCount);
+
+		else
+		{
+			$newer = !$lastExistingRevision ||
+				$lastLocalRevision->getTimestamp() > $lastExistingRevision->getTimestamp();
+			if ($successCount > 0)
+			{
+				/* Conflict */
+				if ($newer)
+				{
+					$linktext = wfMsgExt( 'import-conflict-difflink',
+						array( 'parsemag', 'escape' ),
+						$lastRevision->getId(),
+						$lastLocalRevision->getId() );
+					$link = $skin->makeKnownLinkObj(
+						$title, $linktext,
+						'diff=' . $lastRevision->getId() .
+						"&oldid=" . $lastLocalRevision->getId() );
+					$msg = wfMsgExt( 'import-conflict',
+						array( 'parsemag' ),
+						$localCount,
+						$link );
+				}
+				/* Page history continued with new revisions */
+				else
+					$msg = wfMsgExt('import-revision-count', array('parsemag', 'escape'), $localCount);
+			}
+			else
+			{
+				/* Local revision is newer */
+				if ($newer)
+					$msg = wfMsgHtml('import-nonewrevisions-localnewer');
+				/* No changes nowhere */
+				else
+					$msg = wfMsgHtml('import-nonewrevisions');
+			}
+		}
+
+		$msg = $skin->makeKnownLinkObj( $title ) . ': ' . $msg;
 
+		$wgOut->addHtml( "<li>$msg</li>" );
+
+		if( $successCount > 0 ) {
 			$log = new LogPage( 'import' );
 			if( $this->mIsUpload ) {
 				$detail = wfMsgExt( 'import-logentry-upload-detail', array( 'content', 'parsemag' ),
@@ -308,8 +354,6 @@ class ImportReporter {
 			# Update page record
 			$article->updateRevisionOn( $dbw, $nullRevision );
 			wfRunHooks( 'NewRevisionFromEditComplete', array($article, $nullRevision, $latest, $wgUser) );
-		} else {
-			$wgOut->addHTML( '<li>' . wfMsgHtml( 'import-nonewrevisions' ) . '</li>' );
 		}
 	}
 
diff --git languages/messages/MessagesEn.php languages/messages/MessagesEn.php
index 0d5771f..8dfc944 100644
--- languages/messages/MessagesEn.php
+++ languages/messages/MessagesEn.php
@@ -2763,8 +2763,16 @@ In the latter case you can also use a link, for example [[{{#Special:Export}}/{{
 'exportnohistory'   => "----
 '''Note:''' Exporting the full history of pages through this form has been disabled due to performance reasons.",
 'export-submit'     => 'Export',
-'export-addcattext' => 'Add pages from category:',
+'export-addpages'   => "'''Add pages:'''",
 'export-addcat'     => 'Add',
+'export-catname'    => 'Category:',
+'export-modifydate' => 'Changed after:',
+'export-namespace'  => 'Namespace:',
+'export-invalid-catname' => '<font color=red>\'\'\'Unknown category ignored: \'$1\'\'\'\'.</font>',
+'export-invalid-namespace' => '<font color=red>\'\'\'Unknown namespace ignored: \'$1\'\'\'\'.</font>',
+'export-invalid-modifydate' => '<font color=red>\'\'\'Incorrect timestamp ignored (use format <u>YYYY-MM-DD HH:MM:SS</u>): \'$1\'\'\'\'.</font>',
+'export-images'     => 'Export images',
+'export-selfcontained' => 'Include image contents into the export file',
 'export-download'   => 'Save as file',
 'export-templates'  => 'Include templates',
 
@@ -2803,7 +2811,6 @@ All transwiki import actions are logged at the [[Special:Log/import|import log]]
 'importtext'                 => 'Please export the file from the source wiki using the [[Special:Export|export utility]].
 Save it to your computer and upload it here.',
 'importstart'                => 'Importing pages...',
-'import-revision-count'      => '$1 {{PLURAL:$1|revision|revisions}}',
 'importnopages'              => 'No pages to import.',
 'importfailed'               => 'Import failed: <nowiki>$1</nowiki>',
 'importunknownsource'        => 'Unknown import source type',
@@ -2822,9 +2829,15 @@ The file was only partially uploaded.',
 A temporary folder is missing.',
 'import-parse-failure'       => 'XML import parse failure',
 'import-noarticle'           => 'No page to import!',
-'import-nonewrevisions'      => 'All revisions were previously imported.',
 'xml-error-string'           => '$1 at line $2, col $3 (byte $4): $5',
 'import-upload'              => 'Upload XML data',
+'import-norevisions'         => 'No revisions to import.',
+'import-nonewrevisions-localnewer' => 'All revisions were previously imported. Page changed locally.',
+'import-nonewrevisions'      => 'All revisions were previously imported. No local changes.',
+'import-revision-count'      => '$1 {{PLURAL:$1|revision|revisions}}',
+'import-revision-count-newpage' => '$1 {{PLURAL:$1|revision|revisions}} (new page)',
+'import-conflict'            => '$1 {{PLURAL:$1|revision|revisions}} (conflict: $2)',
+'import-conflict-difflink'   => '$1 (imported) и $2 (local)',
 'import-token-mismatch'      => 'Loss of session data. Please try again.',
 'import-invalid-interwiki'   => 'Cannot import from the specified wiki.',
 
diff --git languages/messages/MessagesRu.php languages/messages/MessagesRu.php
index f213cff..e2010af 100644
--- languages/messages/MessagesRu.php
+++ languages/messages/MessagesRu.php
@@ -2321,8 +2321,16 @@ $1',
 'exportnohistory'   => "----
 '''Замечание:''' экспорт полной истории изменений страниц отключен из-за проблем с производительностью.",
 'export-submit'     => 'Экспортировать',
-'export-addcattext' => 'Добавить страницы из категории:',
+'export-addpages'   => "'''Добавить страницы:'''",
 'export-addcat'     => 'Добавить',
+'export-catname'    => 'Категория:',
+'export-modifydate' => 'Изменённые после:',
+'export-namespace'  => 'Пространство имён:',
+'export-invalid-catname' => '<font color=red>\'\'\'Некорректное имя категории проигнорировано: \'$1\'\'\'\'.</font>',
+'export-invalid-namespace' => '<font color=red>\'\'\'Неизвестное пространство имён проигнорировано: \'$1\'\'\'\'.</font>',
+'export-invalid-modifydate' => '<font color=red>\'\'\'Некорректные дата и время проигнорированы (используйте формат <u>YYYY-MM-DD HH:MM:SS</u>): \'$1\'\'\'\'.</font>',
+'export-images'     => 'Экспортировать изображения',
+'export-selfcontained' => 'Включать содержимое изображений в экспортный файл',
 'export-download'   => 'Предложить сохранить как файл',
 'export-templates'  => 'Включить шаблоны',
 
@@ -2360,7 +2368,6 @@ $1',
 'import-comment'             => 'Примечание:',
 'importtext'                 => 'Пожалуйста, экспортируйте страницу из исходной вики, используя [[Special:Export|соответствующий инструмент]]. Сохраните файл на диск, а затем загрузите его сюда.',
 'importstart'                => 'Импортирование страниц…',
-'import-revision-count'      => '$1 {{PLURAL:$1|версия|версии|версий}}',
 'importnopages'              => 'Нет страниц для импортирования.',
 'importfailed'               => 'Не удалось импортировать: $1',
 'importunknownsource'        => 'Неизвестный тип импортируемой страницы',
@@ -2376,9 +2383,15 @@ $1',
 'importuploaderrortemp'      => 'Не удалось загрузить или импортировать файл. Временная папка отсутствует.',
 'import-parse-failure'       => 'Ошибка разбора XML при импорте',
 'import-noarticle'           => 'Нет страницы для импортирования!',
-'import-nonewrevisions'      => 'Все редакции были ранее импортированы.',
 'xml-error-string'           => '$1 в строке $2, позиции $3 (байт $4): $5',
 'import-upload'              => 'Загрузить XML-данные',
+'import-norevisions'         => 'Нет редакций для импортирования.',
+'import-nonewrevisions-localnewer' => 'Все редакции были ранее импортированы. Страница изменена локально.',
+'import-nonewrevisions'      => 'Все редакции были ранее импортированы. Локальных изменений нет.',
+'import-revision-count'      => '$1 {{PLURAL:$1|версия|версии|версий}}.',
+'import-revision-count-newpage' => '$1 {{PLURAL:$1|версия|версии|версий}} (новая страница).',
+'import-conflict'            => '$1 {{PLURAL:$1|версия|версии|версий}} (конфликт: $2).',
+'import-conflict-difflink'   => '$1 (импорт) и $2 (локальная)',
 'import-token-mismatch'      => 'Потеряны данные сеанса. Пожалуйста, попробуйте ещё раз.',
 'import-invalid-interwiki'   => 'Невозможно импортировать из указанной вики.',
 
-- 
tg: (a708bbe..) t/001-import-export-images-and-conflicts (depends on: t/000-translit-upload-filenames)
